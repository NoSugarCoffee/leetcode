'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/leetcode/docs/%E5%89%91%E6%8C%87-offer/readme/',title:"剑指 offer",section:"类别",content:"04. 二维数组中的查找 #  leetcode\n// ../../../../src/main/java/com/dll/offer/Offer04.java  package com.dll.offer; public class Offer04 { class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { int rows; if (matrix == null || (rows = matrix.length) \u0026lt; 1) { return false; } int cols = matrix[0].length; int i = 0; int j = cols - 1; while (i \u0026lt; rows \u0026amp;\u0026amp; j \u0026gt; -1) { int upperRightCorner = matrix[i][j]; if (upperRightCorner == target) { return true; } else if (upperRightCorner \u0026gt; target) { j--; } else { i++; } } return false; } } } 05. 替换空格 #  leetcode\n// ../../../../src/main/java/com/dll/offer/Offer05.java  package com.dll.offer; import java.util.stream.Stream; public class Offer05 { class Solution { public String replaceSpace(String s) { if (s == null) { return \u0026#34;\u0026#34;; } StringBuilder sb = new StringBuilder(); Stream.of(s.split(\u0026#34;\u0026#34;)).forEach(ss -\u0026gt; { if (\u0026#34; \u0026#34;.equals(ss)) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(ss); } }); return sb.toString(); } } } 06. 从尾到头打印链表 #  leetcode\n递归法 #  // ../../../../src/main/java/com/dll/offer/Offer06.java  package com.dll.offer; import java.util.ArrayList; import java.util.List; public class Offer06 { class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public int[] reversePrint(ListNode head) { return this.recursion(head).stream().mapToInt(i -\u0026gt; i).toArray(); } private List\u0026lt;Integer\u0026gt; recursion(ListNode node) { if (node == null) { return new ArrayList\u0026lt;\u0026gt;(); } List\u0026lt;Integer\u0026gt; list = this.recursion(node.next); list.add(node.val); return list; } } } 07. 重建二叉树 #  leetcode\n根据前序和中序遍历的规则，前序遍历总是将树分割成 {根 [左子树] [右子树]}，中序遍历则将树分割成 {[左子树] 根 [右子树]}，两者左右子树的成员应该保持一致。\n具体的，当还原前序遍历为 {1,2,4,7,3,5,6,8}，中序遍历为 {4,7,2,1,5,3,8,6} 的树时，需要经历以下步骤:\n  根据前序遍历 {1,2,4,7,3,5,6,8} 可得 1 是树的根结点\n  结合中序遍历可知左子树中序结果为 {4,7,2}, 前序结果为 {2,4,7}, 右子树中序结果为 {5,3,8,6}, 前序结果为 {3,5,6,8}\n  对子树重复上述步骤\n  伪代码表示一个流程如下：\npreorder = [1,2,4,7,3,5,6,8] inorder = [4,7,2,1,5,3,8,6] root = preorder[0] # 拆分成两颗子树 subLeftTreeInorder, subRightTreeInorder = splitInorder(root) subLeftTreeInorderlength = subLeftTreeInorder.length() subRightTreeInorderlength = subRightTreeInorder.length() subLeftTreePreorder = preorder[1:subLeftTreeInorderlength] subRightTreePreorder = preorder[subLeftTreeInorderlength:subRightTreeInorderlength] subLeftTreeRoot = subLeftTreePreorder[0] subRightTreeRoot = subRightTreePreorder[0] root.left = subLeftTreeRoot root.right = subRightTreeRoot 经过上述直叙的方式，可以抽象成如下递归体：\nfunc Node rec(preorder, inorder) { root = preorder[0] subLeftTreeInorder, subRightTreeInorder = splitInorder(preorder[0]) subLeftTreeInorderlength = subLeftTreeInorder.length() subRightTreeInorderlength = subRightTreeInorder.length() subLeftTreePreorder = preorder[1:subLeftTreeInorderlength] subRightTreePreorder = preorder[subLeftTreeInorderlength:subRightTreeInorderlength] left = rec(subLeftTreePreorder, subLeftTreeInorder) right = rec(subRightTreePreorder, subRightTreeInorder) root.left = left root.right = right return root } // ../../../../src/main/java/com/dll/offer/Offer07.java  package com.dll.offer; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.TreeMap; public class Offer07 { class LevelTreeNode { TreeNode node; int level; public LevelTreeNode(TreeNode node, int level) { this.node = node; this.level = level; } } class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) { return null; } if (preorder.length != inorder.length) { throw new RuntimeException( String.format(\u0026#34;internal error, preorder:%s inorder:%s\u0026#34;, Arrays.toString(preorder), Arrays.toString(inorder))); } int rootValue = preorder[0]; int[][] subTreeInorder = this.splitInorder(inorder, rootValue); int[] leftInorder = subTreeInorder[0]; int[] rightInorder = subTreeInorder[1]; int leftTreeLength = leftInorder.length; int rightTreeLength = rightInorder.length; int[] leftPreorder = new int[]{}; int[] rightPreorder = new int[]{}; if (leftTreeLength \u0026gt; 0) { leftPreorder = Arrays.copyOfRange(preorder, 1, 1 + leftTreeLength); } if (rightTreeLength \u0026gt; 0) { rightPreorder = Arrays.copyOfRange(preorder, 1 + leftTreeLength, preorder.length); } TreeNode left = buildTree(leftPreorder, leftInorder); TreeNode right = buildTree(rightPreorder, rightInorder); TreeNode root = new TreeNode(rootValue); root.left = left; root.right = right; return root; } private int findIndexInArray(int[] array, int root) { int index = 0; for (int value: array) { if (value == root) { return index; } index++; } return -1; } int[][] splitInorder(int[] inorder, int root) { int rootIndex = this.findIndexInArray(inorder, root); if (rootIndex == -1) { return new int[][]{{},{}}; } int[] left = Arrays.copyOfRange(inorder, 0, rootIndex); int[] right = Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length); return new int[][]{left, right}; } // this also can solve problem https://leetcode-cn.com/problems/binary-tree-level-order-traversal/  public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { // map key is level, map value is the list of node value  if (root == null) { return new ArrayList\u0026lt;\u0026gt;(new ArrayList\u0026lt;\u0026gt;()); } Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(Comparator.comparingInt(Integer::valueOf)); Deque\u0026lt;LevelTreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(new LevelTreeNode(root, 0)); while (!queue.isEmpty()) { LevelTreeNode n = queue.poll(); List\u0026lt;Integer\u0026gt; list = map.getOrDefault(n.level, new ArrayList\u0026lt;\u0026gt;()); map.put(n.level, list); list.add(n.node.val); if (n.node.left != null) { queue.offer(new LevelTreeNode(n.node.left, n.level + 1)); } if (n.node.right != null) { queue.offer(new LevelTreeNode(n.node.right, n.level + 1)); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } } 09. 用两个栈实现队列 #  leetcode\n利用两个栈, deQueueStack 以及 enQueueStack\n 入队只从 enQueueStack 进 出队只从 deQueueStack 出，deQueueStack 内有元素时直接出队, 无元素时转移全部 enQueueStack 到 deQueueStack  // ../../../../src/main/java/com/dll/offer/Offer09.java  package com.dll.offer; import java.util.Deque; import java.util.LinkedList; import java.util.NoSuchElementException; public class Offer09 { class CQueue { Deque\u0026lt;Integer\u0026gt; inQueueStack = new LinkedList\u0026lt;\u0026gt;(); Deque\u0026lt;Integer\u0026gt; deQueueStack = new LinkedList\u0026lt;\u0026gt;(); public CQueue() { } public void appendTail(int value) { inQueueStack.push(value); } private int popWrapper() { try { return deQueueStack.pop(); } catch (NoSuchElementException e) { return -1; } } public int deleteHead() { if (deQueueStack.isEmpty()) { while (!inQueueStack.isEmpty()) { deQueueStack.push(inQueueStack.pop()); } } return popWrapper(); } } } 10- I. 斐波那契数列 #  leetcode\n直接递归会超时，所以加了个简易的 cache\n// ../../../../src/main/java/com/dll/offer/Offer10I.java  package com.dll.offer; import java.util.HashMap; import java.util.Map; public class Offer10I { class Solution { Map\u0026lt;Integer, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public int fib(int n) { if (cache.containsKey(n)) { return cache.get(n); } if (n \u0026lt; 2) { return n; } int val = (fib(n - 1) + fib(n - 2)) % 1000000007; cache.put(n, val); return val; } } } 10- II. 青蛙跳台阶问题 #  leetcode\n斐波那契数列包了一层背景，原理一样\n// ../../../../src/main/java/com/dll/offer/Offer10II.java  package com.dll.offer; import java.util.HashMap; import java.util.Map; public class Offer10II { class Solution { Map\u0026lt;Integer, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); private int recu(int n) { if (cache.containsKey(n)) { return cache.get(n); } if (n == 0 || n == 1) { return 1; } int val = (recu(n - 1) + recu(n - 2)) % 1000000007; cache.put(n, val); return val; } public int numWays(int n) { return recu(n); } } } 11. 旋转数组的最小数字 #  这题直接用暴力法解了，因为个人觉得题目没什么太大实际意义 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer11.java  package com.dll.offer; public class Offer11 { class Solution { public int minArray(int[] numbers) { if (numbers == null || numbers.length \u0026lt; 1) { throw new RuntimeException(); } int min = numbers[0]; for (int i = 1; i \u0026lt; numbers.length; i++) { if (numbers[i] \u0026lt; numbers[i - 1]) { min = numbers[i]; break; } } return min; } } } 18. 删除链表的节点 #  leetcode\n// ../../../../src/main/java/com/dll/offer/Offer18.java  package com.dll.offer; public class Offer18 { class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode pre = null; ListNode cur = head; while (cur != null) { if (cur.val == val) { if (pre == null) { cur = cur.next; head = cur; } else { pre.next = cur.next; cur = cur.next; } } else { pre = cur; cur = cur.next; } } return head; } } } 24. 反转链表 #  leetcode\n// ../../../../src/main/java/com/dll/offer/Offer24.java  package com.dll.offer; public class Offer24 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; ListNode next = null; while(current != null) { next = current.next; current.next = prev; prev = current; current = next; } return prev; } } } 25. 合并两个排序的链表 #  leetcode\n// ../../../../src/main/java/com/dll/offer/Offer25.java  package com.dll.offer; public class Offer25 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode p1 = l1; ListNode p2 = l2; ListNode dummy = new ListNode(-1); ListNode last = dummy; while(p1 != null \u0026amp;\u0026amp; p2 != null) { if ( p1.val \u0026gt; p2.val) { last.next = p2; p2 = p2.next; } else { last.next = p1; p1 = p1.next; } last = last.next; } if (p1 != null) { last.next = p1; } if (p2 != null) { last.next = p2; } return dummy.next; } } } 52. 两个链表的第一个公共节点 #  leetcode\n 要比较的是 node 是否相等，而不是 value 是否相等。 由于是单向链表，即重合后一定是 “Y” 型，而不是 “X” 型，尾部长度一致。 使链表 A 和链表 B 末尾对齐，同时遍历，出现相同结点则直接返回，直到遍历至末尾都没有相同结点则返回 null。  时空复杂度\n 时间复杂度: O(len(A) + len(B))) 空间复杂度：O(1)  // ../../../../src/main/java/com/dll/offer/Offer52.java  package com.dll.offer; public class Offer52 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode getIntersectionNOde(ListNode headA, ListNode headB) { ListNode pa = headA; ListNode pb = headB; int lenA = 0; int lenB = 0; while(pa != null) { lenA++; pa = pa.next; } while(pb != null) { lenB++; pb = pb.next; } int distance = Math.abs(lenA - lenB); ListNode pLong = headA; ListNode pShort = headB; if (lenB \u0026gt; lenA) { pLong = headB; pShort = headA; } while(distance-- \u0026gt; 0) { pLong = pLong.next; } while(pLong != null) { if (pLong == pShort) { return pLong; } pLong = pLong.next; pShort = pShort.next; } return null; } } } "}),a.add({id:1,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/',title:"双指针",section:"其他",content:"双指针 #  167. 两数之和 II - 输入有序数组 #  leetcode\n由于数组升序, 分别使用指针 ps 指向数组开头, 指针 pe 指向数组末尾, 当 array[ps] + array[pe] \u0026gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target\n// ../../../../../src/main/java/com/dll/doublePoint/TwoSumIIInputArrayIsSorted.java  package com.dll.doublePoint; public class TwoSumIIInputArrayIsSorted { class Solution { public int[] twoSum(int[] numbers, int target) { int ps = 0; int pe = numbers.length - 1; while (ps \u0026lt; pe) { if (numbers[ps] + numbers[pe] == target) { return new int[]{ps + 1, pe + 1}; } else if (numbers[ps] + numbers[pe] \u0026gt; target) { pe--; } else { ps++; } } return new int[]{-1, -1}; } } } 88. 合并两个有序数组 #  leetcode\n开辟足够大的 nums3, p1、p2 分别指向两个有序数组初始位置, 存储当前指针指向的较小值至 nums3 且移动指针, 相等则任选\n// ../../../../../src/main/java/com/dll/doublePoint/MergeSortedArray.java  package com.dll.doublePoint; public class MergeSortedArray { class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int[] nums3 = new int[m + n]; int p1 = 0; int p2 = 0; int index = 0; while (p1 \u0026lt; m \u0026amp;\u0026amp; p2 \u0026lt; n) { if (nums1[p1] \u0026lt;= nums2[p2]) { nums3[index] = nums1[p1]; p1++; } else { nums3[index] = nums2[p2]; p2++; } index++; } for (; p1 \u0026lt; m; p1++) { nums3[index++] = nums1[p1]; } for (; p2 \u0026lt; n; p2++) { nums3[index++] = nums2[p2]; } System.arraycopy(nums3, 0, nums1, 0, m + n); } } } 142. 环形链表 II #  leetcode\n哈希法 #  该思路比较直接, 后续在补充\n快慢指针 #  该思路比较有趣, 具体如下: 若存在环时, 遍历永不结束。慢指针每次走 1 步, 快指针每次走 2 步, 成环时快指针总是能追上慢指针。那么如何知道入口点, 由已知关系得:\n 快指针路径长 = 2 倍慢指针的路径 = n 圈路径长 + a + b 2(a+b) = a+b+(b+c)*n a+b = (b+c)n a = (b+c)n-b a = (b+c)(n-1)+c 从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离 在表头新建指针与 slow 同步移动, 相交处即为入口点\n// ../../../../../src/main/java/com/dll/doublePoint/LinkedListCycleII.java  package com.dll.doublePoint; class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class LinkedListCycleII { public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow, fast, find; try { find = head; slow = head.next; fast = slow.next; } catch (NullPointerException e) { return null; } while (fast != null) { if (fast == slow) { while (find != slow) { find = find.next; slow = slow.next; } return find; } fast = fast.next; slow = slow.next; if (fast != null) { fast = fast.next; } else { return null; } } return null; } } } 76. 最小覆盖子串 #  leetcode\n滑动窗口 #  原字符 ori（s），以及需要包含的字符串 need（t），[l,r) 代表当前窗口，r 右滑直至满足条件，此时通过 l 右滑，可能找到最优解，重复直到结束。\n// ../../../../../src/main/java/com/dll/doublePoint/MinimumWindowSubstring.java  package com.dll.doublePoint; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; public class MinimumWindowSubstring { class Solution { public Map\u0026lt;Character, Integer\u0026gt; calc_freq(String s) { Map\u0026lt;Character, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { freq.put(s.charAt(i), freq.getOrDefault(s.charAt(i), 0) + 1); } return freq; } public boolean check(Map\u0026lt;Character, Integer\u0026gt; window_freq, Map\u0026lt;Character, Integer\u0026gt; need_freq) { Iterator\u0026lt;Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; iterator = need_freq.entrySet().iterator(); while (iterator.hasNext()) { Entry\u0026lt;Character, Integer\u0026gt; next = iterator.next(); Character key = next.getKey(); if (!(window_freq.containsKey(key) \u0026amp;\u0026amp; window_freq.get(key) \u0026gt;= next.getValue())) { return false; } } return true; } public String minWindow(String s, String t) { String ori = s; String need = t; int l = 0; int r = 0; String result = \u0026#34;\u0026#34;; Map\u0026lt;Character, Integer\u0026gt; needFreq = calc_freq(need); Map\u0026lt;Character, Integer\u0026gt; window_frep = new HashMap\u0026lt;\u0026gt;(); int endIndex = ori.length() - 1; while (r \u0026lt;= endIndex) { window_frep.put(ori.charAt(r), window_frep.getOrDefault(ori.charAt(r), 0) + 1); while (check(window_frep, needFreq) \u0026amp;\u0026amp; l \u0026lt;= r) { if (\u0026#34;\u0026#34;.equals(result)) { result = ori.substring(l, r + 1); } else { result = ori.substring(l, r + 1).length() \u0026lt; result.length() ? ori.substring(l, r + 1) : result; } window_frep.put(ori.charAt(l), window_frep.getOrDefault(ori.charAt(l), 0) - 1); l++; } r++; } return result; } } } "}),a.add({id:2,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/',title:"排序",section:"其他",content:"排序 #  快速排序 #  冒泡排序 #  // ../../../../src/sort/BubbleSort.java  package sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { this.swap(arr, j, j + 1); swapped = true; } } if (!swapped) { break; } } } } 选择排序 #  // ../../../../src/sort/QuickSelect.java  package sort; public class QuickSelect { class Solution { private void swap(int[] nums, int first, int second) { int temp = nums[first]; nums[first] = nums[second]; nums[second] = temp; } private int recursion(int[] nums, int l, int r, int k) { int pivot = l; int start = l; int end = r; while(start \u0026lt; end) { while (start \u0026lt; end \u0026amp;\u0026amp; nums[end] \u0026gt;= nums[pivot] ) { end--; } while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] \u0026lt;= nums[pivot]) { start++; } this.swap(nums, start, end); } this.swap(nums, start, pivot); int topN = nums.length - pivot; if (topN == k) { return nums[pivot]; } else if (topN \u0026lt; k) { int result = this.recursion(nums, l, pivot - 1, k); if(result != -1) { return result; } } else { int result = this.recursion(nums, pivot + 1, r, k); if(result != -1) { return result; } } return -1; } public int findKthLargest(int[] nums, int k) { return this.recursion(nums, 0, nums.length - 1, k); } } } 归并排序 #  // ../../../../src/sort/MergeSort.java  package sort; import java.util.Arrays; public class MergeSort { /** * 用于合并两个升序的数组 */ public int[] mergeSortedArray(int[] arr1, int[] arr2) { int[] merged = new int[arr1.length + arr2.length]; int i = 0; int j = 0; int k = 0; while (i \u0026lt; arr1.length \u0026amp;\u0026amp; j \u0026lt; arr2.length) { merged[k++] = arr1[i] \u0026gt; arr2[j] ? arr2[j++] : arr1[i++]; } while (i \u0026lt; arr1.length) { merged[k++] = arr1[i++]; } while (j \u0026lt; arr2.length) { merged[k++] = arr2[j++]; } return merged; } // [start, mid)  // [mid, end)  public int[] merge(int[] arr, int start, int mid, int end) { int[] t1 = Arrays.copyOfRange(arr, start, mid); int[] t2 = Arrays.copyOfRange(arr, mid, end); int[] result = this.mergeSortedArray(t1, t2); for (int i = 0; i \u0026lt; result.length; i++) { arr[start + i] = result[i]; } return result; } public void splitAndMerge(int[] arr, int start, int end) { if (end - start \u0026lt;= 1) { return; } int mid = start + (end - start) / 2; this.splitAndMerge(arr, start, mid); this.splitAndMerge(arr, mid, end); this.merge(arr, start, mid, end); } public void sort(int[] arr) { this.splitAndMerge(arr, 0, arr.length); } } 插入排序 #  // ../../../../src/sort/InsertSort.java  package sort; /** * 插入排序将数组分为两个部分:有序部分和待排序部分 * 待排序部分中的每个元素和有序部分的每个元素做比较，并插入到合适的位置 * 第一个元素本身就是有序的，不需要排序 * 从第二个元素开始，每次都比较 */ public class InsertSort { public void sort(int[] arr) { for (int i = 1; i \u0026lt; arr.length; i++) { for (int j = 0; j \u0026lt; i; j++) { if (arr[i] \u0026lt; arr[j]) { int temp = arr[i]; for (int z = i - 1; z \u0026gt;= j; z--) { arr[z + 1] = arr[z]; } arr[j] = temp; } } } } } 215. Kth Largest Element in an Array #  两数的交换 #  排序过程中经常会使用到两个数值的交换，常用的，我们会使用 temp variable 作为媒介，如：\n t = a; a = b; b = t; 有没有不耗费空间，或者更快的方式呢？\n  数值运算交换两个元素\n a = a + b // a1 = a + b b = a - b // b = a1 - b -\u0026gt; b = a a = a - b // a = a1 - b -\u0026gt; a = a1 - a -\u0026gt; a = b   异或运算交换两个元素\n a = a ^ b // a1 = a ^ b b = a ^ b // b = a1 ^ b -\u0026gt; a ^ b ^ b = a a = a ^ b // a = a1 ^ b -\u0026gt; a ^ b ^ a = b   "}),a.add({id:3,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/',title:"贪心",section:"其他",content:"贪心 #  455. 分发饼干 #  leetcode\n 对每块饼干都去匹配一下胃口，满足饼干 \u0026gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列  // ../../../../../src/main/java/com/dll/greedy/AssignCookies.java  package com.dll.greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename  int[] appetites = g; int[] cookies = s; // ascending  Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter \u0026lt; appetites.length \u0026amp;\u0026amp; cookie \u0026gt;= appetites[counter]) { counter++; } } return counter; } } } 135. 分发糖果 #  leetcode\n我的思路 #   把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1  如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -\u0026gt; [1,1,1,1,1,1,1] 1 -\u0026gt; [1,2,1,1,1,1,1] 2 -\u0026gt; [1,2,3,1,1,1,1] 3 -\u0026gt; [1,2,3,1,3,1,1] 5 -\u0026gt; [1,2,3,4,3,1,1] 7 -\u0026gt; [1,2,3,4,2,1,2] 书上思路 #   把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1  // ../../../../../src/main/java/com/dll/greedy/Candy.java  package com.dll.greedy; import java.util.Arrays; import java.util.Optional; import java.util.stream.IntStream; public class Candy { class Solution { public int candy(int[] ratings) { // use candy array to store result  int[] candy = new int[ratings.length]; // uniq and ascending  int[] uniqAndSortedRats = IntStream.of(ratings).distinct().sorted().toArray(); // set default value  Arrays.fill(candy, 1); for (int uasr : uniqAndSortedRats) { for (int i = 0; i \u0026lt; ratings.length; i++) { if (uasr == ratings[i]) { this.updateCandy(ratings, candy, i); } } System.out.println(Arrays.toString(candy)); } return IntStream.of(candy).sum(); } Optional\u0026lt;Integer\u0026gt; getLeftValue(int[] arr, int index) { if (index == 0) { return Optional.empty(); } return Optional.of(arr[index - 1]); } Optional\u0026lt;Integer\u0026gt; getRightValue(int[] arr, int index) { if (index == arr.length - 1) { return Optional.empty(); } return Optional.of(arr[index + 1]); } int max(int a, int b) { return a \u0026gt; b ? a : b; } void updateCandy(int[] ratings, int[] candy, int index) { // 判断 ratings[index] 是否存在比 ratings[index - 1] or ratings[index + 1] 大  // true 则按照如下更新：  // 1. 左右均比其大，则取 max(candy[index-1], candy(index+1)) + 1  // 2. 一侧大则取一侧的值 + 1  // false 则不更新  int current = ratings[index]; Optional\u0026lt;Integer\u0026gt; leftRatingsValue = getLeftValue(ratings, index); Optional\u0026lt;Integer\u0026gt; rightRatingsValue = getRightValue(ratings, index); Optional\u0026lt;Integer\u0026gt; leftCandyValue = getLeftValue(candy, index); Optional\u0026lt;Integer\u0026gt; rightCandyValue = getRightValue(candy, index); if ((leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) \u0026amp;\u0026amp; (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current)) { candy[index] = max(leftCandyValue.get(), rightCandyValue.get()) + 1; } else if (leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) { candy[index] = leftCandyValue.get() + 1; } else if (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current) { candy[index] = rightCandyValue.get() + 1; } } } } 435. 无重叠区间 #  leetcode\n我的思路 #  错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：\n[5,7] [3,6] [6,20] 正确应该是去除 [5,7] 区间 但是按照我的思路会选 [5,7] 去除 [3,6] [6,20] 区间 书上思路 #  按照区间右端点升序排列，且一直维护当前右端点为不重复区间的最大右端点\n// ../../../../../src/main/java/com/dll/greedy/NonOverlappingIntervals.java  package com.dll.greedy; import java.util.Arrays; import java.util.Comparator; public class NonOverlappingIntervals { class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length \u0026lt; 1) { return 0; } Arrays.sort(intervals, Comparator.comparingInt(o -\u0026gt; o[1])); int end = intervals[0][1]; int counter = 0; for (int i = 1; i \u0026lt; intervals.length; i++) { if (intervals[i][0] \u0026lt; end) { counter++; } else { end = intervals[i][1]; } } return counter; } } } 605. 种花问题 #  leetcode\n我的思路 #  在 1 的左右侧设置\u0026rsquo;障碍物', 用 2 代表, 根据连续多少个 0, 能发现如下规律:\n连续 1 个 0 -\u0026gt; 可种 1 朵花 连续 2 个 0 -\u0026gt; 可种 1 朵花 连续 3 个 0 -\u0026gt; 可种 2 朵花 连续 n 个 0 -\u0026gt; 可种 (n+1)/2 朵花 // ../../../../../src/main/java/com/dll/greedy/CanPlaceFlowers.java  package com.dll.greedy; public class CanPlaceFlowers { class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int zeroCountContinuous = 0; int counter = 0; for (int i = 0; i \u0026lt; flowerbed.length; i++) { if (flowerbed[i] == 1) { if (i - 1 \u0026gt;= 0) { flowerbed[i - 1] = 2; if (zeroCountContinuous \u0026gt; 0) { zeroCountContinuous--; } } if (i + 1 \u0026lt; flowerbed.length) { flowerbed[i + 1] = 2; } counter += (zeroCountContinuous + 1) / 2; zeroCountContinuous = 0; } else if (flowerbed[i] == 0) { zeroCountContinuous++; } } if (zeroCountContinuous \u0026gt; 0) { counter += (zeroCountContinuous + 1) / 2; } return counter \u0026gt;= n; } } } 贪心策略 (TODO) #  遍历，能种就种（在可种的时候不种都不会得到更优解）\n452. 用最少数量的箭引爆气球 #  leetcode\n |----| A |---| B |----| C |------------| D |--| E 通过观察不难发现可以取任一线段(气球), 尝试找与其有交集的任一线段, 若不存在, 则此线段是独立线段, 花费一支箭, 若存在, 则继续找下一条与该交集相交的线段（尽可能多的）, 直至不存在, 花费一支箭\n然而写完代码发现这个思路竟然是错误的！\n例: [3,8],[7,12],[9,10],[0,6]\n |---| [3,8] A |------------| [7,12] B |---| [9,10] C |----| [0,6] D 按照代码逻辑: AB 一箭, C 一箭, D 一箭 事实存在更优: AD 一箭, BC 一箭 进一步, 如果按照其左或右端点排序, 就能 AC 该问题(虽然效率很低)\n|----| [0,6] D |---| [3,8] A |---| [9,10] C |------------| [7,12] B // ../../../../../src/main/java/com/dll/greedy/MinimumNumberOfArrowsToBurstBalloons.java  package com.dll.greedy; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List; public class MinimumNumberOfArrowsToBurstBalloons { class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, Comparator.comparingInt(o -\u0026gt; o[1])); List\u0026lt;int[]\u0026gt; balloons = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(points)); int arrows = 0; while (!balloons.isEmpty()) { int[] p1 = balloons.get(0); balloons.remove(0); for (int i = 0; i \u0026lt; balloons.size(); i++) { if ((balloons.get(i)[0] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[0] \u0026lt;= p1[1]) || (balloons.get(i)[1] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026lt;= p1[1]) || (balloons.get(i)[0] \u0026lt; p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026gt; p1[1])) { int start = balloons.get(i)[0] \u0026gt; p1[0] ? balloons.get(i)[0] : p1[0]; int end = balloons.get(i)[1] \u0026lt; p1[1] ? balloons.get(i)[1] : p1[1]; p1 = new int[]{start, end}; balloons.remove(i--); } } arrows++; } return arrows; } } } 为啥排序能解决问题？\n排序解除了\u0026rsquo;剩两端\u0026rsquo;的问题, 如上例中, 当 AB 组合的时候, 可能会同时存在类似 C.start \u0026gt; A.end , D.end \u0026lt; B.start 的情形, 而排序后刚好破坏了这种情形\n |---| [3,8] A |------------| [7,12] B |\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; C \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;| D "}),a.add({id:4,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/%E9%93%BE%E8%A1%A8/readme/',title:"链表",section:"其他",content:"链表 #  82. 删除排序链表中的重复元素 II #  leetcode\n// ../../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedListII82.java  package com.dll.linkedList; public class RemoveDuplicatesFromSortedListII82 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(); ListNode tail = dummy; ListNode cur = head; while(cur != null) { ListNode next = cur.next; if (next == null) { tail.next = cur; tail = tail.next; cur = cur.next; } else if(cur.val != next.val) { tail.next = cur; tail = tail.next; cur = cur.next; } else { cur = findNextUnDuplicatedNodeWithHead(cur); } } tail.next = null; return dummy.next; } /** * find the node closest to the head with different value * example: 1-\u0026gt;2-\u0026gt;2 return 2 * example: 2-\u0026gt;2-\u0026gt;3 return 3 * example: 1-\u0026gt;1-\u0026gt;1 return null * example: null return null * @param head of the list * @return the node closest to the head with different value or null */ ListNode findNextUnDuplicatedNodeWithHead(ListNode head) { if (head == null || head.next == null) { return null; } if (head.val != head.next.val) { return head.next; } return findNextUnDuplicatedNodeWithHead(head.next); } } } 83. 删除排序链表中的重复元素 #  leetcode\n// ../../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedList83.java  package com.dll.linkedList; public class RemoveDuplicatesFromSortedList83 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head.next; while (cur != null) { if(cur.val == pre.val) { cur = cur.next; pre.next = cur; } else { pre = cur; cur = cur.next; } } return head; } } } 203. 移除链表元素 #  leetcode\n 增加一个 dummy 结点使删除头结点和中间结点的逻辑一致 p 总是指向当前需要做逻辑判断的结点， pre 则为 p 的前一个结点 p 指向的结点 val 与给定一致时，删除 p 结点，即 pre.next = p.next pre 与 p 的维护：当结点删除，下一轮的 pre 不需要变动，p = p.next，否则一直保持 pre 和 p 的前进  // ../../../../../src/main/java/com/dll/linkedList/RemoveLinkedListElements203.java  package com.dll.linkedList; public class RemoveLinkedListElements203 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode p = head; while(p != null) { if(p.val == val) { pre.next = p.next; } else { pre = p; } p = p.next; } return dummy.next; } } } "}),a.add({id:5,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/',title:"二分查找",section:"其他",content:"二分查找 #  69. x 的平方根 #  leetcode\n查找满足 a*a \u0026lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可\n// ../../../../../src/main/java/com/dll/binarySearch/MySqrt.java  package com.dll.binarySearch; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l \u0026lt;= r) { //NOTE: 不考虑 long 一直超出事件限制  int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } 34. 在排序数组中查找元素的第一个和最后一个位置 #  leetcode\n使用二分法找出左右边界\n// ../../../../../src/main/java/com/dll/binarySearch/FindFirstAndLastPositionOfElementInSortedArray.java  package com.dll.binarySearch; public class FindFirstAndLastPositionOfElementInSortedArray { class Solution { public int[] searchRange(int[] nums, int target) { int l = 0; int r = nums.length - 1; int res1 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026lt; target) { l = mid + 1; } else { r = mid - 1; if (nums[mid] == target) { res1 = mid; } } } l = 0; r = nums.length - 1; int res2 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026gt; target) { r = mid - 1; } else { l = mid + 1; if (nums[mid] == target) { res2 = mid; } } } return new int[]{res1, res2}; } } } "}),a.add({id:6,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/',title:"LRU 缓存",section:"其他",content:"146. LRU 缓存机制 #  leetcode\n// ../../../../../src/main/java/com/dll/leetcode/LRUCache146.java  package com.dll.leetcode; import java.util.HashMap; import java.util.Map; public class LRUCache146 { class DoubleLinkedList { private Map\u0026lt;Integer, Node\u0026gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap\u0026lt;\u0026gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.key = key; this.prev = prev; this.value = value; this.next = next; } } private boolean containsKey(int key) { return this.map.containsKey(key); } public Node get(int key) { return this.map.getOrDefault(key, null); } public void delete(Node node) { Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; this.map.remove(node.key); this.size--; } private Node addFirst(int key, int value) { Node node = new Node(head, key, value, head.next); head.next.prev = node; head.next = node; this.size++; this.map.put(key, node); return node; } private Node deleteLast() { Node deletedPrev = tail.prev.prev; Node deleted = deletedPrev.next; deletedPrev.next = tail; tail.prev = deletedPrev; this.map.remove(deleted.key); return deleted; } } private DoubleLinkedList list = new DoubleLinkedList(); private int capacity; public LRUCache146(int capacity) { if (capacity \u0026lt;= 0) { throw new RuntimeException(); } this.capacity = capacity; } /** * get value by key from cache * @param key key of cache * @return value of key */ public int get(int key) { DoubleLinkedList.Node node = list.get(key); if (node == null) { return -1; } list.delete(node); list.addFirst(node.key, node.value); return node.value; } /** * put key and value to cache * @param key key of cache * @param value value of key */ public void put(int key, int value) { // 1. exist in map -\u0026gt; remove(value) \u0026amp; push(value)  // 2. don\u0026#39;t exist in map -\u0026gt; deque is full -\u0026gt; removeLast \u0026amp; push(value)  // 3. don\u0026#39;t exist in map -\u0026gt; deque is empty -\u0026gt; push(value)  if (list.containsKey(key)) { list.delete(list.get(key)); } else { if (list.getSize() \u0026gt;= this.capacity) { list.deleteLast(); } } list.addFirst(key, value); } } "}),a.add({id:7,href:'/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/readme/',title:"多线程",section:"其他",content:"多线程 #  1115. 交替打印FooBar #  leetcode\n利用 AtomicBoolean 来互斥的访问临界资源\n// ../../../../../src/main/java/com/dll/multithreads/PrintFoobarAlternately.java  package com.dll.multithreads; import java.util.concurrent.atomic.AtomicBoolean; public class PrintFoobarAlternately { class FooBar { private int n; private AtomicBoolean flag = new AtomicBoolean(true); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { while (!flag.get()) { Thread.yield(); } // printFoo.run() outputs \u0026#34;foo\u0026#34;. Do not change or remove this line.  printFoo.run(); flag.set(false); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { while (flag.get()) { Thread.yield(); } // printBar.run() outputs \u0026#34;bar\u0026#34;. Do not change or remove this line.  printBar.run(); flag.set(true); } } } } "})})()