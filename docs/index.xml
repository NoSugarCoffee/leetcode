<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法分类 on LeetCode solutions</title><link>https://nosugarcoffee.github.io/leetcode/docs/</link><description>Recent content in 算法分类 on LeetCode solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://nosugarcoffee.github.io/leetcode/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>贪心</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E8%B4%AA%E5%BF%83/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E8%B4%AA%E5%BF%83/readme/</guid><description>贪心 # AssignCookies # 我的思路 # 对每块饼干都去匹配一下胃口，满足饼干&amp;gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列 Candy # 我的思路 # 把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1 如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -&amp;gt; [1,1,1,1,1,1,1] 1 -&amp;gt; [1,2,1,1,1,1,1] 2 -&amp;gt; [1,2,3,1,1,1,1] 3 -&amp;gt; [1,2,3,1,3,1,1] 5 -&amp;gt; [1,2,3,4,3,1,1] 7 -&amp;gt; [1,2,3,4,2,1,2] 书上思路 # 把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1 无重叠区间 # 我的思路 # 错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：</description></item><item><title>排序</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</guid><description>双指针 # 待补充
目录 # 167. Two Sum II - Input array is sorted 88. Merge Sorted Array 142. linked-list-cycle-ii 哈希法 快慢指针 76. minimum-window-substring 167. Two Sum II - Input array is sorted # 由于数组升序排列, 分别使用指针 ps 指向数组开头, 指针 pe 指向数组末尾, 当 array[ps] + array[pe] &amp;gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target
88. Merge Sorted Array # 开辟足够大的 nums3, p1、p2 分别指向两个有序数组初始位置, 储存当前指针指向的较小值至 nums3 且移动指针, 相等则任选</description></item><item><title>二分查找</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</guid><description>二分查找 # Sqrt(x) # 查找满足 a*a &amp;lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可
Find-first-and-last-position-of-element-in-sorted-array # 使用二分法找出左右边界</description></item><item><title>排序</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E6%8E%92%E5%BA%8F/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E6%8E%92%E5%BA%8F/readme/</guid><description>排序 # 快速排序 # 冒泡排序 # 选择排序 # 归并排序 # 插入排序 # 两数的交换 # 排序过程中经常会使用到两个数值的交换，常用的，我们会使用 temp variable 作为媒介，如：
t = a; a = b; b = t; 有没有不耗费空间，或者更快的方式呢？
数值运算交换两个元素 a = a + b // a1 = a + b b = a - b // b = a1 - b -&amp;gt; b = a a = a - b // a = a1 - b -&amp;gt; a = a1 - a -&amp;gt; a = b 异或运算交换两个元素 a = a ^ b // a1 = a ^ b b = a ^ b // b = a1 ^ b -&amp;gt; a ^ b ^ b = a a = a ^ b // a = a1 ^ b -&amp;gt; a ^ b ^ a = b</description></item></channel></rss>