<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>其他 on LeetCode solutions</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on LeetCode solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>双指针</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</guid><description>双指针 # 167. Two Sum II - Input array is sorted # 由于数组升序排列, 分别使用指针 ps 指向数组开头, 指针 pe 指向数组末尾, 当 array[ps] + array[pe] &amp;gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target
// ../../../../src/doublePoint/TwoSumIIInputArrayIsSorted.java package doublePoint; public class TwoSumIIInputArrayIsSorted { class Solution { public int[] twoSum(int[] numbers, int target) { int ps = 0; int pe = numbers.length - 1; while (ps &amp;lt; pe) { if (numbers[ps] + numbers[pe] == target) { return new int[]{ps + 1, pe + 1}; } else if (numbers[ps] + numbers[pe] &amp;gt; target) { pe--; } else { ps++; } } return new int[]{-1, -1}; } } } 88.</description></item><item><title>排序</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/</guid><description>排序 # 快速排序 # 冒泡排序 # // ../../../../src/sort/BubbleSort.java package sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i &amp;lt; arr.length - 1; i++) { for (int j = 0; j &amp;lt; arr.length - i - 1; j++) { if (arr[j] &amp;gt; arr[j + 1]) { this.</description></item><item><title>贪心</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/</guid><description>贪心 # AssignCookies # 我的思路 # 对每块饼干都去匹配一下胃口，满足饼干&amp;gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列 // ../../../../src/greedy/AssignCookies.java package greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename int[] appetites = g; int[] cookies = s; // ascending Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter &amp;lt; appetites.length &amp;amp;&amp;amp; cookie &amp;gt;= appetites[counter]) { counter++; } } return counter; } } } Candy # 我的思路 # 把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1 如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -&amp;gt; [1,1,1,1,1,1,1] 1 -&amp;gt; [1,2,1,1,1,1,1] 2 -&amp;gt; [1,2,3,1,1,1,1] 3 -&amp;gt; [1,2,3,1,3,1,1] 5 -&amp;gt; [1,2,3,4,3,1,1] 7 -&amp;gt; [1,2,3,4,2,1,2] 书上思路 # 把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1 // .</description></item><item><title>二分查找</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</guid><description>二分查找 # Sqrt(x) # 查找满足 a*a &amp;lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可
// ../../../../src/binarySearch/Mysqrt.java package binarySearch; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l &amp;lt;= r) { //NOTE: 不考虑 long 一直超出事件限制 int mid = l + (r - l) / 2; if ((long) mid * mid &amp;lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } Find-first-and-last-position-of-element-in-sorted-array # 使用二分法找出左右边界</description></item><item><title>LRU 缓存</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/</guid><description>LRU 缓存 # leetcode
// ../../../../src/main/java/com/dll/leetcode/LRUCache146.java package com.dll.leetcode; import java.util.HashMap; import java.util.Map; public class LRUCache146 { class DoubleLinkedList { private Map&amp;lt;Integer, Node&amp;gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap&amp;lt;&amp;gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.</description></item></channel></rss>