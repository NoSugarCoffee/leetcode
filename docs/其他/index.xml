<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>其他 on LeetCode solutions</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/</link><description>Recent content in 其他 on LeetCode solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/index.xml" rel="self" type="application/rss+xml"/><item><title>双指针</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</guid><description>双指针 # 88. 合并两个有序数组 # leetcode
开辟足够大的 nums3, p1、p2 分别指向两个有序数组初始位置, 存储当前指针指向的较小值至 nums3 且移动指针, 相等则任选
// ../../../../../src/main/java/com/dll/doublePoint/MergeSortedArray.java package com.dll.doublePoint; public class MergeSortedArray { class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int[] nums3 = new int[m + n]; int p1 = 0; int p2 = 0; int index = 0; while (p1 &amp;lt; m &amp;amp;&amp;amp; p2 &amp;lt; n) { if (nums1[p1] &amp;lt;= nums2[p2]) { nums3[index] = nums1[p1]; p1++; } else { nums3[index] = nums2[p2]; p2++; } index++; } for (; p1 &amp;lt; m; p1++) { nums3[index++] = nums1[p1]; } for (; p2 &amp;lt; n; p2++) { nums3[index++] = nums2[p2]; } System.</description></item><item><title>排序</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/</guid><description>排序 # 冒泡排序 # // ../../../../../src/main/java/com/dll/sort/BubbleSort.java package com.dll.sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i &amp;lt; arr.length - 1; i++) { for (int j = 0; j &amp;lt; arr.length - i - 1; j++) { if (arr[j] &amp;gt; arr[j + 1]) { this.</description></item><item><title>数组</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%95%B0%E7%BB%84/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%95%B0%E7%BB%84/readme/</guid><description>数组 # N 数之和 # 1. 两数之和 # leetcode
// ../../../../../src/main/java/com/dll/array/TwoSum.java package com.dll.array; import java.util.HashMap; import java.util.Map; public class TwoSum { // 1. 暴力法 class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i &amp;lt; nums.length; i++) { for (int j = i + 1; j &amp;lt; nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return new int[]{-1, -1}; } } // 2.</description></item><item><title>贪心</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/</guid><description>贪心 # 455. 分发饼干 # leetcode
对每块饼干都去匹配一下胃口，满足饼干 &amp;gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列 // ../../../../../src/main/java/com/dll/greedy/AssignCookies.java package com.dll.greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename int[] appetites = g; int[] cookies = s; // ascending Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter &amp;lt; appetites.length &amp;amp;&amp;amp; cookie &amp;gt;= appetites[counter]) { counter++; } } return counter; } } } 135.</description></item><item><title>链表</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E9%93%BE%E8%A1%A8/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E9%93%BE%E8%A1%A8/readme/</guid><description>链表 # 2. 两数相加 # leetcode
各个位置上的结点相加并需要考虑进位 // ../../../../../src/main/java/com/dll/linkedList/AddTwoNumbers2.java package com.dll.linkedList; public class AddTwoNumbers2 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = new ListNode(-1); ListNode last = head; int pre = 0; while(l1 !</description></item><item><title>二分查找</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</guid><description>二分查找 # 69. x 的平方根 # leetcode
查找满足 a*a &amp;lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可
// ../../../../../src/main/java/com/dll/binarySearch/MySqrt.java package com.dll.binarySearch; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l &amp;lt;= r) { //NOTE: 不考虑 long 一直超出事件限制 int mid = l + (r - l) / 2; if ((long) mid * mid &amp;lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } 34.</description></item><item><title>字符串</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%AD%97%E7%AC%A6%E4%B8%B2/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%AD%97%E7%AC%A6%E4%B8%B2/readme/</guid><description>字符串 # 344. 反转字符串 # leetcode
// ../../../../../src/main/java/com/dll/string/ReverseString.java package com.dll.string; public class ReverseString { class Solution { private void swap(char[] s, int p, int q) { char temp = s[p]; s[p] = s[q]; s[q] = temp; } public void reverseString(char[] s) { if (s.length &amp;lt;= 1) { return; } for (int i = 0; i &amp;lt; s.length / 2; i++) { int p = i; int q = s.</description></item><item><title>LRU 缓存</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/</guid><description>146. LRU 缓存机制 # leetcode
// ../../../../../src/main/java/com/dll/leetcode/LRUCache146.java package com.dll.leetcode; import java.util.HashMap; import java.util.Map; public class LRUCache146 { class DoubleLinkedList { private Map&amp;lt;Integer, Node&amp;gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap&amp;lt;&amp;gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.</description></item><item><title>哈希表</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%93%88%E5%B8%8C%E8%A1%A8/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%93%88%E5%B8%8C%E8%A1%A8/readme/</guid><description>哈希表 # 242. 有效的字母异位词 # leetcode
分别用 map 存储两个字符串的字符词频 // ../../../../../src/main/java/com/dll/hashtable/ValidAnagram.java package com.dll.hashtable; import java.util.HashMap; import java.util.Map; public class ValidAnagram { class Solution { private Map&amp;lt;Character, Integer&amp;gt; toCharMap(String s) { Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;(); char[] chars = s.toCharArray(); for (char c: chars) { int val = map.getOrDefault(c, 0); map.put(c, val + 1); } return map; } public boolean isAnagram(String s, String t) { if (s.</description></item><item><title>多线程</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/readme/</guid><description>多线程 # 1115. 交替打印FooBar # leetcode
利用 AtomicBoolean 来互斥的访问临界资源
// ../../../../../src/main/java/com/dll/multithreads/PrintFoobarAlternately.java package com.dll.multithreads; import java.util.concurrent.atomic.AtomicBoolean; public class PrintFoobarAlternately { class FooBar { private int n; private AtomicBoolean flag = new AtomicBoolean(true); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &amp;lt; n; i++) { while (!flag.get()) { Thread.yield(); } // printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.</description></item></channel></rss>