<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on LeetCode solutions</title><link>https://nosugarcoffee.github.io/leetcode/</link><description>Recent content in Introduction on LeetCode solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://nosugarcoffee.github.io/leetcode/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指 offer</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%89%91%E6%8C%87-offer/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%89%91%E6%8C%87-offer/readme/</guid><description>04. 二维数组中的查找 # leetcode
// ../../../../src/main/java/com/dll/offer/Offer04.java package com.dll.offer; public class Offer04 { class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { int rows; if (matrix == null || (rows = matrix.length) &amp;lt; 1) { return false; } int cols = matrix[0].length; int i = 0; int j = cols - 1; while (i &amp;lt; rows &amp;amp;&amp;amp; j &amp;gt; -1) { int upperRightCorner = matrix[i][j]; if (upperRightCorner == target) { return true; } else if (upperRightCorner &amp;gt; target) { j--; } else { i++; } } return false; } } } 05.</description></item><item><title>双指针</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%8F%8C%E6%8C%87%E9%92%88/readme/</guid><description>双指针 # 167. 两数之和 II - 输入有序数组 # leetcode
由于数组升序, 分别使用指针 ps 指向数组开头, 指针 pe 指向数组末尾, 当 array[ps] + array[pe] &amp;gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target
// ../../../../../src/main/java/com/dll/doublePoint/TwoSumIIInputArrayIsSorted.java package com.dll.doublePoint; public class TwoSumIIInputArrayIsSorted { class Solution { public int[] twoSum(int[] numbers, int target) { int ps = 0; int pe = numbers.length - 1; while (ps &amp;lt; pe) { if (numbers[ps] + numbers[pe] == target) { return new int[]{ps + 1, pe + 1}; } else if (numbers[ps] + numbers[pe] &amp;gt; target) { pe--; } else { ps++; } } return new int[]{-1, -1}; } } } 88.</description></item><item><title>排序</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E6%8E%92%E5%BA%8F/readme/</guid><description>排序 # 快速排序 # 冒泡排序 # // ../../../../src/sort/BubbleSort.java package sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i &amp;lt; arr.length - 1; i++) { for (int j = 0; j &amp;lt; arr.length - i - 1; j++) { if (arr[j] &amp;gt; arr[j + 1]) { this.</description></item><item><title>贪心</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E8%B4%AA%E5%BF%83/readme/</guid><description>贪心 # 455. 分发饼干 # leetcode
对每块饼干都去匹配一下胃口，满足饼干 &amp;gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列 // ../../../../../src/main/java/com/dll/greedy/AssignCookies.java package com.dll.greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename int[] appetites = g; int[] cookies = s; // ascending Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter &amp;lt; appetites.length &amp;amp;&amp;amp; cookie &amp;gt;= appetites[counter]) { counter++; } } return counter; } } } 135.</description></item><item><title>链表</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E9%93%BE%E8%A1%A8/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E9%93%BE%E8%A1%A8/readme/</guid><description>链表 # 82. 删除排序链表中的重复元素 II # leetcode
// ../../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedListII82.java package com.dll.linkedList; public class RemoveDuplicatesFromSortedListII82 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(); ListNode tail = dummy; ListNode cur = head; while(cur !</description></item><item><title>二分查找</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/</guid><description>二分查找 # 69. x 的平方根 # leetcode
查找满足 a*a &amp;lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可
// ../../../../../src/main/java/com/dll/binarySearch/MySqrt.java package com.dll.binarySearch; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l &amp;lt;= r) { //NOTE: 不考虑 long 一直超出事件限制 int mid = l + (r - l) / 2; if ((long) mid * mid &amp;lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } 34.</description></item><item><title>LRU 缓存</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/lru%E7%BC%93%E5%AD%98/readme/</guid><description>146. LRU 缓存机制 # leetcode
// ../../../../../src/main/java/com/dll/leetcode/LRUCache146.java package com.dll.leetcode; import java.util.HashMap; import java.util.Map; public class LRUCache146 { class DoubleLinkedList { private Map&amp;lt;Integer, Node&amp;gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap&amp;lt;&amp;gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.</description></item><item><title>多线程</title><link>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://nosugarcoffee.github.io/leetcode/docs/%E5%85%B6%E4%BB%96/%E5%A4%9A%E7%BA%BF%E7%A8%8B/readme/</guid><description>多线程 # 1115. 交替打印FooBar # leetcode
利用 AtomicBoolean 来互斥的访问临界资源
// ../../../../../src/main/java/com/dll/multithreads/PrintFoobarAlternately.java package com.dll.multithreads; import java.util.concurrent.atomic.AtomicBoolean; public class PrintFoobarAlternately { class FooBar { private int n; private AtomicBoolean flag = new AtomicBoolean(true); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i &amp;lt; n; i++) { while (!flag.get()) { Thread.yield(); } // printFoo.run() outputs &amp;#34;foo&amp;#34;. Do not change or remove this line.</description></item></channel></rss>