'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/leetcode/docs/%E8%B4%AA%E5%BF%83/readme/',title:"贪心",section:"算法分类",content:"贪心 #  AssignCookies #  我的思路 #   对每块饼干都去匹配一下胃口，满足饼干\u0026gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列  // ../../../../src/greedy/AssignCookies.java  package greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename  int[] appetites = g; int[] cookies = s; // ascending  Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter \u0026lt; appetites.length \u0026amp;\u0026amp; cookie \u0026gt;= appetites[counter]) { counter++; } } return counter; } } } Candy #  我的思路 #   把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1  如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -\u0026gt; [1,1,1,1,1,1,1] 1 -\u0026gt; [1,2,1,1,1,1,1] 2 -\u0026gt; [1,2,3,1,1,1,1] 3 -\u0026gt; [1,2,3,1,3,1,1] 5 -\u0026gt; [1,2,3,4,3,1,1] 7 -\u0026gt; [1,2,3,4,2,1,2] 书上思路 #   把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1  // ../../../../src/greedy/Candy.java  package greedy; import java.util.Arrays; import java.util.Optional; import java.util.stream.IntStream; public class Candy { class Solution { public int candy(int[] ratings) { // use candy array to store result  int[] candy = new int[ratings.length]; // uniq and ascending  int[] uniqAndSortedRats = IntStream.of(ratings).distinct().sorted().toArray(); // set default value  Arrays.fill(candy, 1); for (int uasr : uniqAndSortedRats) { for (int i = 0; i \u0026lt; ratings.length; i++) { if (uasr == ratings[i]) { this.updateCandy(ratings, candy, i); } } System.out.println(Arrays.toString(candy)); } return IntStream.of(candy).sum(); } Optional\u0026lt;Integer\u0026gt; getLeftValue(int[] arr, int index) { if (index == 0) { return Optional.empty(); } return Optional.of(arr[index - 1]); } Optional\u0026lt;Integer\u0026gt; getRightValue(int[] arr, int index) { if (index == arr.length - 1) { return Optional.empty(); } return Optional.of(arr[index + 1]); } int max(int a, int b) { return a \u0026gt; b ? a : b; } void updateCandy(int[] ratings, int[] candy, int index) { // 判断 ratings[index] 是否存在比 ratings[index - 1] or ratings[index + 1] 大  // true 则按照如下更新：  // 1. 左右均比其大，则取 max(candy[index-1], candy(index+1)) + 1  // 2. 一侧大则取一侧的值 + 1  // false 则不更新  int current = ratings[index]; Optional\u0026lt;Integer\u0026gt; leftRatingsValue = getLeftValue(ratings, index); Optional\u0026lt;Integer\u0026gt; rightRatingsValue = getRightValue(ratings, index); Optional\u0026lt;Integer\u0026gt; leftCandyValue = getLeftValue(candy, index); Optional\u0026lt;Integer\u0026gt; rightCandyValue = getRightValue(candy, index); if ((leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) \u0026amp;\u0026amp; (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current)) { candy[index] = max(leftCandyValue.get(), rightCandyValue.get()) + 1; } else if (leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) { candy[index] = leftCandyValue.get() + 1; } else if (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current) { candy[index] = rightCandyValue.get() + 1; } } } } 无重叠区间 #  我的思路 #  错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：\n[5,7] [3,6] [6,20] 正确应该是去除 [5,7] 区间 但是按照我的思路会选 [5,7] 去除 [3,6] [6,20] 区间 书上思路 #  按照区间右端点升序排列，且一直维护当前右端点为不重复区间的最大右端点\n// ../../../../src/greedy/NonOverlappingIntervals.java  package greedy; import java.util.Arrays; import java.util.Comparator; public class NonOverlappingIntervals { class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length \u0026lt; 1) { return 0; } Arrays.sort(intervals, Comparator.comparingInt(o -\u0026gt; o[1])); int end = intervals[0][1]; int counter = 0; for (int i = 1; i \u0026lt; intervals.length; i++) { if (intervals[i][0] \u0026lt; end) { counter++; } else { end = intervals[i][1]; } } return counter; } } } CanPlaceFlowers #  我的思路 #  在 1 的左右侧设置\u0026rsquo;障碍物', 用 2 代表, 根据连续多少个 0, 能发现如下规律:\n连续 1 个 0 -\u0026gt; 可种 1 朵花 连续 2 个 0 -\u0026gt; 可种 1 朵花 连续 3 个 0 -\u0026gt; 可种 2 朵花 连续 n 个 0 -\u0026gt; 可种 (n+1)/2 朵花 // ../../../../src/greedy/CanPlaceFlowers.java  package greedy; public class CanPlaceFlowers { class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int zeroCountContinuous = 0; int counter = 0; for (int i = 0; i \u0026lt; flowerbed.length; i++) { if (flowerbed[i] == 1) { if (i - 1 \u0026gt;= 0) { flowerbed[i - 1] = 2; if (zeroCountContinuous \u0026gt; 0) { zeroCountContinuous--; } } if (i + 1 \u0026lt; flowerbed.length) { flowerbed[i + 1] = 2; } counter += (zeroCountContinuous + 1) / 2; zeroCountContinuous = 0; } else if (flowerbed[i] == 0) { zeroCountContinuous++; } } if (zeroCountContinuous \u0026gt; 0) { counter += (zeroCountContinuous + 1) / 2; } return counter \u0026gt;= n; } } } 贪心策略 (TODO) #  遍历，能种就种（在可种的时候不种都不会得到更优解）\nminimum-number-of-arrows-to-burst-balloons #   |----| A |---| B |----| C |------------| D |--| E 通过观察不难发现可以取任一线段(气球), 尝试找与其有交集的任一线段, 若不存在, 则此线段是独立线段, 花费一支箭, 若存在, 则继续找下一条与该交集相交的线段（尽可能多的）, 直至不存在, 花费一支箭\n然而写完代码发现这个思路竟然是错误的！\n例: [3,8],[7,12],[9,10],[0,6]\n |---| [3,8] A |------------| [7,12] B |---| [9,10] C |----| [0,6] D 按照代码逻辑: AB 一箭, C 一箭, D 一箭 事实存在更优: AD 一箭, BC 一箭 进一步, 如果按照其左或右端点排序, 就能 AC 该问题(虽然效率很低)\n|----| [0,6] D |---| [3,8] A |---| [9,10] C |------------| [7,12] B // ../../../../src/greedy/MinimumNumberOfArrowsToBurstBalloons.java  package greedy; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List; public class MinimumNumberOfArrowsToBurstBalloons { class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, Comparator.comparingInt(o -\u0026gt; o[1])); List\u0026lt;int[]\u0026gt; balloons = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(points)); int arrows = 0; while (!balloons.isEmpty()) { int[] p1 = balloons.get(0); balloons.remove(0); for (int i = 0; i \u0026lt; balloons.size(); i++) { if ((balloons.get(i)[0] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[0] \u0026lt;= p1[1]) || (balloons.get(i)[1] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026lt;= p1[1]) || (balloons.get(i)[0] \u0026lt; p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026gt; p1[1])) { int start = balloons.get(i)[0] \u0026gt; p1[0] ? balloons.get(i)[0] : p1[0]; int end = balloons.get(i)[1] \u0026lt; p1[1] ? balloons.get(i)[1] : p1[1]; p1 = new int[]{start, end}; balloons.remove(i--); } } arrows++; } return arrows; } } } 为啥排序能解决问题？\n排序解除了\u0026rsquo;剩两端\u0026rsquo;的问题, 如上例中, 当 AB 组合的时候, 可能会同时存在类似 C.start \u0026gt; A.end , D.end \u0026lt; B.start 的情形, 而排序后刚好破坏了这种情形\n |---| [3,8] A |------------| [7,12] B |\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; C \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;| D "}),a.add({id:1,href:'/leetcode/docs/%E5%8F%8C%E6%8C%87%E9%92%88/readme/',title:"双指针",section:"算法分类",content:"双指针 #  167. Two Sum II - Input array is sorted #  由于数组升序排列, 分别使用指针 ps 指向数组开头, 指针 pe 指向数组末尾, 当 array[ps] + array[pe] \u0026gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target\n// ../../../../src/doublePoint/TwoSumIIInputArrayIsSorted.java  package doublePoint; public class TwoSumIIInputArrayIsSorted { class Solution { public int[] twoSum(int[] numbers, int target) { int ps = 0; int pe = numbers.length - 1; while (ps \u0026lt; pe) { if (numbers[ps] + numbers[pe] == target) { return new int[]{ps + 1, pe + 1}; } else if (numbers[ps] + numbers[pe] \u0026gt; target) { pe--; } else { ps++; } } return new int[]{-1, -1}; } } } 88. Merge Sorted Array #  开辟足够大的 nums3, p1、p2 分别指向两个有序数组初始位置, 储存当前指针指向的较小值至 nums3 且移动指针, 相等则任选\n// ../../../../src/doublePoint/MergeSortedArray.java  package doublePoint; public class MergeSortedArray { class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int[] nums3 = new int[m + n]; int p1 = 0; int p2 = 0; int index = 0; while (p1 \u0026lt; m \u0026amp;\u0026amp; p2 \u0026lt; n) { if (nums1[p1] \u0026lt;= nums2[p2]) { nums3[index] = nums1[p1]; p1++; } else { nums3[index] = nums2[p2]; p2++; } index++; } for (; p1 \u0026lt; m; p1++) { nums3[index++] = nums1[p1]; } for (; p2 \u0026lt; n; p2++) { nums3[index++] = nums2[p2]; } System.arraycopy(nums3, 0, nums1, 0, m + n); } } } 142. linked-list-cycle-ii #    哈希法\n该思路比较直接也比较简单, 后续在补充\n  快慢指针\n该思路比较有趣, 具体如下:\n若存在环时, 遍历永不结束。慢指针每次走 1 步, 快指针每次走 2 步, 成环时快指针总是能追上慢指针\n那么如何知道入口点, 由已知关系得:\n 快指针路径长 = 2 倍慢指针的路径 = n 圈路径长 + a + b 2(a+b) = a+b+(b+c)*n a+b = (b+c)n a = (b+c)n-b a = (b+c)(n-1)+c 从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离   在表头新建指针与 slow 同步移动, 相交处即为入口点\n// ../../../../src/doublePoint/LinkedListCycleII.java  package doublePoint; class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class LinkedListCycleII { public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow, fast, find; try { find = head; slow = head.next; fast = slow.next; } catch (NullPointerException e) { return null; } while (fast != null) { if (fast == slow) { while (find != slow) { find = find.next; slow = slow.next; } return find; } fast = fast.next; slow = slow.next; if (fast != null) { fast = fast.next; } else { return null; } } return null; } } } 76. minimum-window-substring #    暴力法\n  滑动窗口\n原字符 ori（s），以及需要包含的字符串 need（t），[l,r) 代表当前窗口，r 右滑直至满足条件，此时通过 l 右滑，可能找到最优解，重复直到结束。\n  // ../../../../src/doublePoint/MinimumWindowSubstring.java  package doublePoint; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; public class MinimumWindowSubstring { class Solution { public Map\u0026lt;Character, Integer\u0026gt; calc_freq(String s) { Map\u0026lt;Character, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { freq.put(s.charAt(i), freq.getOrDefault(s.charAt(i), 0) + 1); } return freq; } public boolean check(Map\u0026lt;Character, Integer\u0026gt; window_freq, Map\u0026lt;Character, Integer\u0026gt; need_freq) { Iterator\u0026lt;Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; iterator = need_freq.entrySet().iterator(); while (iterator.hasNext()) { Entry\u0026lt;Character, Integer\u0026gt; next = iterator.next(); Character key = next.getKey(); if (!(window_freq.containsKey(key) \u0026amp;\u0026amp; window_freq.get(key) \u0026gt;= next.getValue())) { return false; } } return true; } public String minWindow(String s, String t) { String ori = s; String need = t; int l = 0; int r = 0; String result = \u0026#34;\u0026#34;; Map\u0026lt;Character, Integer\u0026gt; needFreq = calc_freq(need); Map\u0026lt;Character, Integer\u0026gt; window_frep = new HashMap\u0026lt;\u0026gt;(); int endIndex = ori.length() - 1; while (r \u0026lt;= endIndex) { window_frep.put(ori.charAt(r), window_frep.getOrDefault(ori.charAt(r), 0) + 1); while (check(window_frep, needFreq) \u0026amp;\u0026amp; l \u0026lt;= r) { if (\u0026#34;\u0026#34;.equals(result)) { result = ori.substring(l, r + 1); } else { result = ori.substring(l, r + 1).length() \u0026lt; result.length() ? ori.substring(l, r + 1) : result; } window_frep.put(ori.charAt(l), window_frep.getOrDefault(ori.charAt(l), 0) - 1); l++; } r++; } return result; } } } "}),a.add({id:2,href:'/leetcode/docs/lru%E7%BC%93%E5%AD%98/readme/',title:"LRU 缓存",section:"算法分类",content:"LRU 缓存 #  // ../../../../src/lrucache_146/LRUCache.java  package lrucache_146; import java.util.HashMap; import java.util.Map; public class LRUCache { class DoubleLinkedList { private Map\u0026lt;Integer, Node\u0026gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap\u0026lt;\u0026gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.key = key; this.prev = prev; this.value = value; this.next = next; } } private boolean containsKey(int key) { return this.map.containsKey(key); } public Node get(int key) { return this.map.getOrDefault(key, null); } public void delete(Node node) { Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; this.map.remove(node.key); this.size--; } private Node addFirst(int key, int value) { Node node = new Node(head, key, value, head.next); head.next.prev = node; head.next = node; this.size++; this.map.put(key, node); return node; } private Node deleteLast() { Node deletedPrev = tail.prev.prev; Node deleted = deletedPrev.next; deletedPrev.next = tail; tail.prev = deletedPrev; this.map.remove(deleted.key); return deleted; } } private DoubleLinkedList list = new DoubleLinkedList(); private int capacity; public LRUCache(int capacity) { if (capacity \u0026lt;= 0) { throw new RuntimeException(); } this.capacity = capacity; } /** * get value by key from cache * @param key key of cache * @return value of key */ public int get(int key) { DoubleLinkedList.Node node = list.get(key); if (node == null) { return -1; } list.delete(node); list.addFirst(node.key, node.value); return node.value; } /** * put key and value to cache * @param key key of cache * @param value value of key */ public void put(int key, int value) { // 1. exist in map -\u0026gt; remove(value) \u0026amp; push(value)  // 2. don\u0026#39;t exist in map -\u0026gt; deque is full -\u0026gt; removeLast \u0026amp; push(value)  // 3. don\u0026#39;t exist in map -\u0026gt; deque is empty -\u0026gt; push(value)  if (list.containsKey(key)) { list.delete(list.get(key)); } else { if (list.getSize() \u0026gt;= this.capacity) { list.deleteLast(); } } list.addFirst(key, value); } } "}),a.add({id:3,href:'/leetcode/docs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/',title:"二分查找",section:"算法分类",content:"二分查找 #  Sqrt(x) #  查找满足 a*a \u0026lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可\n// ../../../../src/binarySearch/Mysqrt.java  package binarySearch; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l \u0026lt;= r) { //NOTE: 不考虑 long 一直超出事件限制  int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } Find-first-and-last-position-of-element-in-sorted-array #  使用二分法找出左右边界\n// ../../../../src/binarySearch/FindFirstAndLastPositionOfElementInSortedArray.java  package binarySearch; public class FindFirstAndLastPositionOfElementInSortedArray { class Solution { public int[] searchRange(int[] nums, int target) { int l = 0; int r = nums.length - 1; int res1 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026lt; target) { l = mid + 1; } else { r = mid - 1; if (nums[mid] == target) { res1 = mid; } } } l = 0; r = nums.length - 1; int res2 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026gt; target) { r = mid - 1; } else { l = mid + 1; if (nums[mid] == target) { res2 = mid; } } } return new int[]{res1, res2}; } } } "}),a.add({id:4,href:'/leetcode/docs/%E6%8E%92%E5%BA%8F/readme/',title:"排序",section:"算法分类",content:"排序 #  快速排序 #  冒泡排序 #  // ../../../../src/sort/BubbleSort.java  package sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { this.swap(arr, j, j + 1); swapped = true; } } if (!swapped) { break; } } } } 选择排序 #  // ../../../../src/sort/QuickSelect.java  package sort; public class QuickSelect { class Solution { private void swap(int[] nums, int first, int second) { int temp = nums[first]; nums[first] = nums[second]; nums[second] = temp; } private int recursion(int[] nums, int l, int r, int k) { int pivot = l; int start = l; int end = r; while(start \u0026lt; end) { while (start \u0026lt; end \u0026amp;\u0026amp; nums[end] \u0026gt;= nums[pivot] ) { end--; } while (start \u0026lt; end \u0026amp;\u0026amp; nums[start] \u0026lt;= nums[pivot]) { start++; } this.swap(nums, start, end); } this.swap(nums, start, pivot); int topN = nums.length - pivot; if (topN == k) { return nums[pivot]; } else if (topN \u0026lt; k) { int result = this.recursion(nums, l, pivot - 1, k); if(result != -1) { return result; } } else { int result = this.recursion(nums, pivot + 1, r, k); if(result != -1) { return result; } } return -1; } public int findKthLargest(int[] nums, int k) { return this.recursion(nums, 0, nums.length - 1, k); } } } 归并排序 #  // ../../../../src/sort/MergeSort.java  package sort; import java.util.Arrays; public class MergeSort { /** * 用于合并两个升序的数组 */ public int[] mergeSortedArray(int[] arr1, int[] arr2) { int[] merged = new int[arr1.length + arr2.length]; int i = 0; int j = 0; int k = 0; while (i \u0026lt; arr1.length \u0026amp;\u0026amp; j \u0026lt; arr2.length) { merged[k++] = arr1[i] \u0026gt; arr2[j] ? arr2[j++] : arr1[i++]; } while (i \u0026lt; arr1.length) { merged[k++] = arr1[i++]; } while (j \u0026lt; arr2.length) { merged[k++] = arr2[j++]; } return merged; } // [start, mid)  // [mid, end)  public int[] merge(int[] arr, int start, int mid, int end) { int[] t1 = Arrays.copyOfRange(arr, start, mid); int[] t2 = Arrays.copyOfRange(arr, mid, end); int[] result = this.mergeSortedArray(t1, t2); for (int i = 0; i \u0026lt; result.length; i++) { arr[start + i] = result[i]; } return result; } public void splitAndMerge(int[] arr, int start, int end) { if (end - start \u0026lt;= 1) { return; } int mid = start + (end - start) / 2; this.splitAndMerge(arr, start, mid); this.splitAndMerge(arr, mid, end); this.merge(arr, start, mid, end); } public void sort(int[] arr) { this.splitAndMerge(arr, 0, arr.length); } } 插入排序 #  // ../../../../src/sort/InsertSort.java  package sort; /** * 插入排序将数组分为两个部分:有序部分和待排序部分 * 待排序部分中的每个元素和有序部分的每个元素做比较，并插入到合适的位置 * 第一个元素本身就是有序的，不需要排序 * 从第二个元素开始，每次都比较 */ public class InsertSort { public void sort(int[] arr) { for (int i = 1; i \u0026lt; arr.length; i++) { for (int j = 0; j \u0026lt; i; j++) { if (arr[i] \u0026lt; arr[j]) { int temp = arr[i]; for (int z = i - 1; z \u0026gt;= j; z--) { arr[z + 1] = arr[z]; } arr[j] = temp; } } } } } 215. Kth Largest Element in an Array #  两数的交换 #  排序过程中经常会使用到两个数值的交换，常用的，我们会使用 temp variable 作为媒介，如：\n t = a; a = b; b = t; 有没有不耗费空间，或者更快的方式呢？\n  数值运算交换两个元素\n a = a + b // a1 = a + b b = a - b // b = a1 - b -\u0026gt; b = a a = a - b // a = a1 - b -\u0026gt; a = a1 - a -\u0026gt; a = b   异或运算交换两个元素\n a = a ^ b // a1 = a ^ b b = a ^ b // b = a1 ^ b -\u0026gt; a ^ b ^ b = a a = a ^ b // a = a1 ^ b -\u0026gt; a ^ b ^ a = b   "})})()