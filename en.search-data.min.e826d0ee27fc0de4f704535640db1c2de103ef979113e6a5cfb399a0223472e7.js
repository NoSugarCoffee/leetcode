'use strict';(function(){const b={cache:!0};b.doc={id:'id',field:['title','content'],store:['title','href','section']};const a=FlexSearch.create('balance',b);window.bookSearchIndex=a,a.add({id:0,href:'/leetcode/docs/%E8%B4%AA%E5%BF%83/readme/',title:"贪心",section:"算法分类",content:"贪心 #  AssignCookies #  我的思路 #   对每块饼干都去匹配一下胃口，满足饼干\u0026gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列  Candy #  我的思路 #   把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1  如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -\u0026gt; [1,1,1,1,1,1,1] 1 -\u0026gt; [1,2,1,1,1,1,1] 2 -\u0026gt; [1,2,3,1,1,1,1] 3 -\u0026gt; [1,2,3,1,3,1,1] 5 -\u0026gt; [1,2,3,4,3,1,1] 7 -\u0026gt; [1,2,3,4,2,1,2] 书上思路 #   把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1  无重叠区间 #  我的思路 #  错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：\n[5,7] [3,6] [6,20] 正确应该是去除 [5,7] 区间 但是按照我的思路会选 [5,7] 去除 [3,6] [6,20] 区间 书上思路 #  按照区间右端点升序排列，且一直维护当前右端点为不重复区间的最大右端点\nCanPlaceFlowers #  我的思路 #  在 1 的左右侧设置\u0026rsquo;障碍物', 用 2 代表, 根据连续多少个 0, 能发现如下规律:\n连续 1 个 0 -\u0026gt; 可种 1 朵花 连续 2 个 0 -\u0026gt; 可种 1 朵花 连续 3 个 0 -\u0026gt; 可种 2 朵花 连续 n 个 0 -\u0026gt; 可种 (n+1)/2 朵花 贪心策略 (TODO) #  遍历，能种就种（在可种的时候不种都不会得到更优解）\nminimum-number-of-arrows-to-burst-balloons #   |----| A |---| B |----| C |------------| D |--| E 通过观察不难发现可以取任一线段(气球), 尝试找与其有交集的任一线段, 若不存在, 则此线段是独立线段, 花费一支箭, 若存在, 则继续找下一条与该交集相交的线段（尽可能多的）, 直至不存在, 花费一支箭\n然而写完代码发现这个思路竟然是错误的！\n例: [3,8],[7,12],[9,10],[0,6]\n |---| [3,8] A |------------| [7,12] B |---| [9,10] C |----| [0,6] D 按照代码逻辑: AB 一箭, C 一箭, D 一箭 事实存在更优: AD 一箭, BC 一箭 进一步, 如果按照其左或右端点排序, 就能 AC 该问题(虽然效率很低)\n|----| [0,6] D |---| [3,8] A |---| [9,10] C |------------| [7,12] B 为啥排序能解决问题？\n排序解除了\u0026rsquo;剩两端\u0026rsquo;的问题, 如上例中, 当 AB 组合的时候, 可能会同时存在类似 C.start \u0026gt; A.end , D.end \u0026lt; B.start 的情形, 而排序后刚好破坏了这种情形\n |---| [3,8] A |------------| [7,12] B |\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; C \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;| D "}),a.add({id:1,href:'/leetcode/docs/%E5%8F%8C%E6%8C%87%E9%92%88/readme/',title:"排序",section:"算法分类",content:"双指针 #  待补充\n目录 #   167. Two Sum II - Input array is sorted 88. Merge Sorted Array 142. linked-list-cycle-ii  哈希法 快慢指针   76. minimum-window-substring  167. Two Sum II - Input array is sorted #  由于数组升序排列, 分别使用指针 ps 指向数组开头, 指针 pe 指向数组末尾, 当 array[ps] + array[pe] \u0026gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target\n88. Merge Sorted Array #  开辟足够大的 nums3, p1、p2 分别指向两个有序数组初始位置, 储存当前指针指向的较小值至 nums3 且移动指针, 相等则任选\n142. linked-list-cycle-ii #    哈希法\n该思路比较直接也比较简单, 后续在补充\n  快慢指针\n该思路比较有趣, 具体如下:\n若存在环时, 遍历永不结束。慢指针每次走 1 步, 快指针每次走 2 步, 成环时快指针总是能追上慢指针\n那么如何知道入口点, 由已知关系得:\n 快指针路径长 = 2 倍慢指针的路径 = n 圈路径长 + a + b 2(a+b) = a+b+(b+c)*n a+b = (b+c)n a = (b+c)n-b a = (b+c)(n-1)+c 从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离   在表头新建指针与 slow 同步移动, 相交处即为入口点\n76. minimum-window-substring #    暴力法\n  滑动窗口\n原字符 ori（s），以及需要包含的字符串 need（t），[l,r) 代表当前窗口，r 右滑直至满足条件，此时通过 l 右滑，可能找到最优解，重复直到结束。\n  "}),a.add({id:2,href:'/leetcode/docs/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/readme/',title:"二分查找",section:"算法分类",content:"二分查找 #  Sqrt(x) #  查找满足 a*a \u0026lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可\nFind-first-and-last-position-of-element-in-sorted-array #  使用二分法找出左右边界\n"}),a.add({id:3,href:'/leetcode/docs/%E6%8E%92%E5%BA%8F/readme/',title:"排序",section:"算法分类",content:"排序 #  快速排序 #  冒泡排序 #  选择排序 #  归并排序 #  插入排序 #  两数的交换 #  排序过程中经常会使用到两个数值的交换，常用的，我们会使用 temp variable 作为媒介，如：\n t = a; a = b; b = t; 有没有不耗费空间，或者更快的方式呢？\n 数值运算交换两个元素   a = a + b // a1 = a + b b = a - b // b = a1 - b -\u0026gt; b = a a = a - b // a = a1 - b -\u0026gt; a = a1 - a -\u0026gt; a = b  异或运算交换两个元素   a = a ^ b // a1 = a ^ b b = a ^ b // b = a1 ^ b -\u0026gt; a ^ b ^ b = a a = a ^ b // a = a1 ^ b -\u0026gt; a ^ b ^ a = b "})})()