[{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%95%B0%E5%AD%A6/","title":"数学","tags":[],"description":"","content":"哈希表 快乐数 202. leetcode\nsquareSumPerPosition 函数计算给定数字的各位置平方和 set 记录每次数字，如果出现重复，则表明一定是无限循环，否则一直在「进步」 // ../../../../src/main/java/com/dll/math/HappyNumber.java package com.dll.math; import java.util.HashSet; import java.util.Set; public class HappyNumber { class Solution { int squareSumPerPosition(int number) { int result = 0; while (number != 0) { result += Math.pow(number % 10, 2); number /= 10; } return result; } public boolean isHappy(int n) { Set\u0026lt;Integer\u0026gt; visited = new HashSet\u0026lt;\u0026gt;(); int next = n; while (!visited.contains(next)) { visited.add(next); next = squareSumPerPosition(next); if (next == 1) { return true; } } return false; } } } 第 N 个泰波那契数 1137. leetcode\n// ../../../../src/main/java/com/dll/math/NThTribonacciNumber.java package com.dll.math; import java.util.HashMap; import java.util.Map; public class NThTribonacciNumber { class Solution { private Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); { map.put(0, 0); map.put(1, 1); map.put(2, 2); } public int tribonacci(int n) { if (map.containsKey(n)) { return map.get(n); } int result = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3); map.put(n, result); return result; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%95%B0%E7%BB%84/","title":"数组","tags":[],"description":"","content":"矩阵中战斗力最弱的 K 行 1337. the-k-weakest-rows-in-a-matrix\n// ../../../../src/main/java/com/dll/array/TheKWeakestRowsInAMatrix.java package com.dll.array; import java.util.Arrays; import java.util.Comparator; import java.util.HashMap; import java.util.Map; import java.util.stream.IntStream; public class TheKWeakestRowsInAMatrix { class Solution { public int[] kWeakestRows(int[][] mat, int k) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); IntStream.range(0, mat.length) .forEach(index -\u0026gt; map.put(index, Arrays.stream(mat[index]).sum())); return map.entrySet().stream() .sorted( Comparator.comparing(Map.Entry\u0026lt;Integer, Integer\u0026gt;::getValue) .thenComparing(Map.Entry::getKey)) .limit(k) .mapToInt(Map.Entry::getKey) .toArray(); } } } 二分查找 704. binary-search\n// ../../../../src/main/java/com/dll/array/BinarySearch.java package com.dll.array; public class BinarySearch { class Solution { public int search(int[] nums, int target) { int leftIndex = 0; int rightIndex = nums.length - 1; while (leftIndex \u0026lt;= rightIndex) { int midIndex = (leftIndex + rightIndex) / 2; if (target == nums[midIndex]) { return midIndex; } else if (nums[midIndex] \u0026gt; target) { rightIndex = midIndex - 1; } else { leftIndex = midIndex + 1; } } return -1; } } } 第一个错误的版本 278. first-bad-version\nleft，right 分别为 1 和 versions.length，mid 为 （left + right） / 2 当 left \u0026lt;= right 时循环并做如下处理:\nversions[mid] is bad version，则 right = mid - 1，并更新 earliestErrVersion = versions[mid] versions[mid] is not bad version，则 left = mid + 1 // ../../../../src/main/java/com/dll/array/FirstBadVersion.java package com.dll.array; import java.util.function.Predicate; public class FirstBadVersion { class VersionControl { boolean isBadVersion(int val) { return false; } } class Solution extends VersionControl { public int searchEarlisetErrVersion(int left, int right, Predicate\u0026lt;Integer\u0026gt; isBadFunc) { int earlisetErrVersion = -1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (isBadFunc.test(mid)) { earlisetErrVersion = mid; right = mid - 1; } else { left = mid + 1; } } return earlisetErrVersion; } public int firstBadVersion(int n) { return this.searchEarlisetErrVersion(1, n, this::isBadVersion); } } } x 的平方根 69. sqrtx\n// ../../../../src/main/java/com/dll/array/MySqrt.java package com.dll.array; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } 在排序数组中查找元素的第一个和最后一个位置 34. find-first-and-last-position-of-element-in-sorted-array\n// ../../../../src/main/java/com/dll/array/FindFirstAndLastPositionOfElementInSortedArray.java package com.dll.array; public class FindFirstAndLastPositionOfElementInSortedArray { class Solution { public int[] searchRange(int[] nums, int target) { int l = 0; int r = nums.length - 1; int res1 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026lt; target) { l = mid + 1; } else { r = mid - 1; if (nums[mid] == target) { res1 = mid; } } } l = 0; r = nums.length - 1; int res2 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026gt; target) { r = mid - 1; } else { l = mid + 1; if (nums[mid] == target) { res2 = mid; } } } return new int[] {res1, res2}; } } } 搜索插入位置 35. search-insert-position\n// ../../../../src/main/java/com/dll/array/SearchInsertPosition.java package com.dll.array; public class SearchInsertPosition { class Solution { private int binarySearch(int[] array, int target) { int left = 0; int right = array.length - 1; int mid = 0; while (left \u0026lt;= right) { mid = left + (right - left) / 2; if (array[mid] \u0026lt; target) { left = mid + 1; } else if (array[mid] \u0026gt; target) { right = mid - 1; } else { break; } } return array[mid] \u0026gt;= target ? mid : mid + 1; } public int searchInsert(int[] nums, int target) { return binarySearch(nums, target); } } } 两数之和 1. two-sum\n// ../../../../src/main/java/com/dll/array/TwoSum.java package com.dll.array; import java.util.HashMap; import java.util.Map; public class TwoSum { // 1. 暴力法 class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[] {i, j}; } } } return new int[] {-1, -1}; } } // 2. hash class Solution2 { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[] {map.get(target - nums[i]), i}; } map.put(nums[i], i); } return new int[] {-1, -1}; } } } 两数之和 II - 输入有序数组 167. two-sum-ii-input-array-is-sorted\n使用指针 ps 指向数组开头, 指针 pe 指向数组末尾 当 numbers[ps] + numbers[pe] \u0026gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target // ../../../../src/main/java/com/dll/array/TwoSumIIInputArrayIsSorted.java package com.dll.array; public class TwoSumIIInputArrayIsSorted { class Solution { // 1. 双指针 public int[] twoSum(int[] numbers, int target) { int ps = 0; int pe = numbers.length - 1; while (ps \u0026lt; pe) { if (numbers[ps] + numbers[pe] == target) { return new int[] {ps + 1, pe + 1}; } else if (numbers[ps] + numbers[pe] \u0026gt; target) { pe--; } else { ps++; } } return new int[] {-1, -1}; } } } 三数之和 15. 3sum\n// ../../../../src/main/java/com/dll/array/ThreeSum.java package com.dll.array; import java.util.*; public class ThreeSum { // 1. 双重循环 + hash 法 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { map.put(nums[i], i); } Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { int z = -nums[i] - nums[j]; if (map.containsKey(z) \u0026amp;\u0026amp; map.get(z) != i \u0026amp;\u0026amp; map.get(z) != j) { Integer[] array = new Integer[] {nums[i], nums[j], z}; Arrays.sort(array); set.add(Arrays.asList(array)); } } } return new ArrayList\u0026lt;\u0026gt;(set); } } // 2. } 四数之和 18. 4sum\n// ../../../../src/main/java/com/dll/array/FourSum.java package com.dll.array; import java.util.*; public class FourSum { // 三重循坏 + hash class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { map.put(nums[i], i); } Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { for (int k = j + 1; k \u0026lt; nums.length; k++) { int z = target - nums[i] - nums[j] - nums[k]; if (map.containsKey(z) \u0026amp;\u0026amp; map.get(z) != i \u0026amp;\u0026amp; map.get(z) != j \u0026amp;\u0026amp; map.get(z) != k) { Integer[] array = new Integer[] {nums[i], nums[j], nums[k], z}; Arrays.sort(array); set.add(Arrays.asList(array)); } } } } return new ArrayList\u0026lt;\u0026gt;(set); } } } 组合 77. combinations\n经过上面的 2、3、4 数之和问题的探索, 发现如果要求「N 个数之和为 target的全部组合」还是有点力不从心，本质上是需要求出给定数组的全部组合，所以先解此题\n// ../../../../src/main/java/com/dll/array/Combinations.java package com.dll.array; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.List; import java.util.stream.IntStream; public class Combinations { // 1. 递归 class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private int k; private int[] data; private void init(int[] data, int k) { this.data = data; this.k = k; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[] {}; } return result; } private void recursion(int[] remain, List\u0026lt;Integer\u0026gt; prevPath) { if (prevPath.size() == k) { result.add(prevPath); return; } for (int i = 0; i \u0026lt; remain.length; i++) { List\u0026lt;Integer\u0026gt; curPath = new ArrayList\u0026lt;\u0026gt;(prevPath); curPath.add(remain[i]); this.recursion(this.remain(remain, i), curPath); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { this.init(IntStream.rangeClosed(1, n).toArray(), k); this.recursion(this.data, Collections.emptyList()); return result; } } // 2. 递归（回溯） class Solution2 { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 遍历过程中的实时路径 private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int k; private int[] data; private void init(int[] data, int k) { this.data = data; this.k = k; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[] {}; } return result; } private void recursion(int[] remain) { if (this.path.size() == k) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; remain.length; i++) { path.add(remain[i]); this.recursion(this.remain(remain, i)); // 回溯 path.remove(path.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { this.init(IntStream.rangeClosed(1, n).toArray(), k); this.recursion(this.data); return result; } } } 组合总和 39. combination-sum\n// ../../../../src/main/java/com/dll/array/CombinationSum.java package com.dll.array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class CombinationSum { class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int sum; private int target; private int[] data; private void init(int[] data, int target) { this.data = data; this.target = target; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index, array.length); } catch (Exception e) { result = new int[] {}; } return result; } private void recursion(int[] array) { if (this.sum == this.target) { result.add(new ArrayList\u0026lt;\u0026gt;(this.path)); return; } if (this.sum \u0026gt; this.target) { return; } for (int i = 0; i \u0026lt; array.length; i++) { this.path.add(array[i]); this.sum += array[i]; this.recursion(this.remain(array, i)); int remove = this.path.remove(this.path.size() - 1); this.sum -= remove; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { this.init(candidates, target); this.recursion(this.data); return result; } } } 组合总和 II 40. combination-sum-ii\n该题就是 组合 提到的「N 数之和为 target 的全部组合问题」，思路同上\n// ../../../../src/main/java/com/dll/array/CombinationSumII.java package com.dll.array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class CombinationSumII { class Solution { private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int[] sorted_candidates; private int[] candidates; private int target; private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private int sum = 0; private void init(int[] candidates, int target) { this.candidates = candidates; int[] candidatesCopy = Arrays.copyOf(candidates, candidates.length); Arrays.sort(candidatesCopy); this.sorted_candidates = candidatesCopy; this.target = target; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[] {}; } return result; } private boolean ifSkipOnContinuesEqual(int[] remain, int index) { return index - 1 \u0026gt;= 0 \u0026amp;\u0026amp; remain[index] == remain[index - 1]; } private void recursion(int[] remain) { if (sum == this.target) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } else if (sum \u0026gt; this.target) { return; } for (int i = 0; i \u0026lt; remain.length; i++) { if (this.ifSkipOnContinuesEqual(remain, i)) { continue; } path.add(remain[i]); sum += remain[i]; this.recursion(this.remain(remain, i)); int val = path.remove(path.size() - 1); sum -= val; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { this.init(candidates, target); this.recursion(this.sorted_candidates); return result; } } } 组合总和 III 216. combination-sum-iii\n// ../../../../src/main/java/com/dll/array/CombinationSumIII.java package com.dll.array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.stream.IntStream; public class CombinationSumIII { class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int sum; private int[] data; private int target; private int k; private void init(int[] data, int target, int k) { this.data = data; this.target = target; this.k = k; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[] {}; } return result; } private void recursion(int[] remain) { if (this.sum == this.target \u0026amp;\u0026amp; this.path.size() == k) { this.result.add(new ArrayList\u0026lt;\u0026gt;(this.path)); } if (this.sum \u0026gt; this.target || this.path.size() \u0026gt; k) { return; } for (int i = 0; i \u0026lt; remain.length; i++) { this.path.add(remain[i]); this.sum += remain[i]; this.recursion(this.remain(remain, i)); int remove = this.path.remove(this.path.size() - 1); this.sum -= remove; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { this.init(IntStream.rangeClosed(1, 9).toArray(), n, k); this.recursion(this.data); return result; } } } 四数相加 II 454. 4sum-ii\n// ../../../../src/main/java/com/dll/array/FourSumII.java package com.dll.array; import java.util.HashMap; import java.util.Map; public class FourSumII { class Solution { public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) { Map\u0026lt;Integer, Integer\u0026gt; m1 = new HashMap\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Integer\u0026gt; m2 = new HashMap\u0026lt;\u0026gt;(); for (int n1 : nums1) { for (int n2 : nums2) { int sum = n1 + n2; m1.compute(sum, (t, u) -\u0026gt; m1.getOrDefault(sum, 0) + 1); } } for (int n3 : nums3) { for (int n4 : nums4) { int sum = n3 + n4; m2.compute(sum, (t, u) -\u0026gt; m2.getOrDefault(sum, 0) + 1); } } int[] result = {0}; m1.forEach( (k1, v1) -\u0026gt; { m2.forEach( (k2, v2) -\u0026gt; { if (k1 + k2 == 0) { result[0] += v1 * v2; } }); }); return result[0]; } } } 有效三角形的个数 611. valid-triangle-number\n满足构成三角形的条件：任意两边之和 \u0026gt; 第三边 不容易想到的是，按照非严格升序的非负数组 [a1,a2,a3\u0026hellip;an] 满足 a[i] \u0026lt;= a[j] \u0026lt;= a[k] (i \u0026lt; j \u0026lt; k 为数组的下标) ， 则有如下隐含条件： a[j] + a[k] \u0026gt;= a[i]，当且仅当 a[i], a[j], a[k] 等于 0 时等号成立，不满足构成三角形条件 a[i] + a[k] \u0026gt;= a[j]，当且仅当 a[i] = 0 时等号成立，不满足构成三角形条件 当手动保证 a[i] + a[j] \u0026gt; a[k] 成立时，可以得到 a[i] \u0026gt; 0，即上述等号不成立，此时满足三角形的条件 // ../../../../src/main/java/com/dll/array/ValidTriangleNumber.java package com.dll.array; import java.util.Arrays; public class ValidTriangleNumber { class Solution { public int triangleNumber(int[] nums) { int[] sortedNums = Arrays.stream(nums).sorted().toArray(); int result = 0; for (int i = 0; i \u0026lt; sortedNums.length; i++) { for (int j = i + 1; j \u0026lt; sortedNums.length; j++) { for (int z = j + 1; z \u0026lt; sortedNums.length; z++) { if (sortedNums[i] + sortedNums[j] \u0026gt; sortedNums[z]) { result++; } } } } return result; } } } 移除元素 27. remove-element\n// ../../../../src/main/java/com/dll/array/RemoveElement.java package com.dll.array; public class RemoveElement { class Solution { public int removeElement(int[] nums, int val) { int p1 = 0; int p2 = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[p1] = nums[p2]; p1++; } p2++; } return p1; } } } 合并两个有序数组 88. merge-sorted-array\n开辟长度为 nums1.length + nums2.length 的空数组 result p1、p2 分别指向两个有序数组起始 index，当任一数组未遍历到末尾时，循环处理以下逻辑： 总是存储当前指针指向的较小值至 result 并维护指针，相等则任选 任一数组遍历完成，把剩余数组存入 result // ../../../../src/main/java/com/dll/array/MergeSortedArray.java package com.dll.array; public class MergeSortedArray { class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int[] result = new int[m + n]; int p1 = 0; int p2 = 0; int index = 0; while (p1 \u0026lt; m \u0026amp;\u0026amp; p2 \u0026lt; n) { if (nums1[p1] \u0026lt;= nums2[p2]) { result[index] = nums1[p1]; p1++; } else { result[index] = nums2[p2]; p2++; } index++; } for (; p1 \u0026lt; m; p1++) { result[index++] = nums1[p1]; } for (; p2 \u0026lt; n; p2++) { result[index++] = nums2[p2]; } System.arraycopy(result, 0, nums1, 0, m + n); } } } 两个数组的交集 349. intersection-of-two-arrays\n两个数组去重且从小到大排列 依次比较两个数组的每个元素，其中 p1，p2 分别为 arr1，arr2 的下标，按照如下逻辑： arr1[p1] = arr[p2]，存储结果，p1 + 1，p2 + 1 arr1[p1] \u0026gt; arr[p2]，p2 + 1 ，反之 // ../../../../src/main/java/com/dll/array/IntersectionOfTwoArrays.java package com.dll.array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class IntersectionOfTwoArrays { class Solution { public int[] intersection(int[] nums1, int[] nums2) { int[] n1 = Arrays.stream(nums1).sorted().distinct().toArray(); int[] n2 = Arrays.stream(nums2).sorted().distinct().toArray(); List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int p1 = 0; int p2 = 0; while (p1 \u0026lt; n1.length \u0026amp;\u0026amp; p2 \u0026lt; n2.length) { if (n1[p1] == n2[p2]) { result.add(n1[p1]); p1++; p2++; } else if (n1[p1] \u0026gt; n2[p2]) { p2++; } else { p1++; } } return result.stream().mapToInt(v -\u0026gt; v).toArray(); } } } 有序数组的平方 977. squares-of-a-sorted-array\n数组非递减排序，故当前数组的平方后的较大值总是出现在数组的两端 新建同等大小的数组用于存储结果，总是把较大值按照从尾部到头部存入 // ../../../../src/main/java/com/dll/array/SquaresOfASortedArray.java package com.dll.array; public class SquaresOfASortedArray { class Solution { public int[] sortedSquares(int[] nums) { int[] newNums = new int[nums.length]; int p = newNums.length - 1; int p1 = 0; int p2 = nums.length - 1; for (int i = 0; i \u0026lt; nums.length; i++) { int p1Square = nums[p1] * nums[p1]; int p2Square = nums[p2] * nums[p2]; if (p1Square \u0026lt; p2Square) { newNums[p] = p2Square; p2--; } else { newNums[p] = p1Square; p1++; } p--; } return newNums; } } } 长度最小的子数组 209. minimum-size-subarray-sum\n// ../../../../src/main/java/com/dll/array/MinimumSizeSubArraySum.java package com.dll.array; import java.util.ArrayDeque; import java.util.Deque; public class MinimumSizeSubArraySum { class Solution { public int minSubArrayLen(int target, int[] nums) { int res = nums.length + 1; Deque\u0026lt;Integer\u0026gt; window = new ArrayDeque\u0026lt;\u0026gt;(); int windowSum = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (windowSum \u0026lt; target) { window.offer(nums[i]); windowSum += nums[i]; } while (windowSum \u0026gt;= target) { if (window.size() \u0026lt; res) { res = window.size(); } int pop = window.remove(); windowSum -= pop; } } return res == nums.length + 1 ? 0 : res; } } } 最短无序连续子数组 581. shortest-unsorted-continuous-subarray\n将 nums 数组排序记为 sortedNums，从首尾两端分别比较 nums 和 sortedNums， 若存在 nums[start] != sortedNums[start] \u0026amp;\u0026amp; nums[end] != sortedNums[end]，则 [start,end] 区间则为所求\n时间复杂度：快排 O(n * logn) 空间复杂度：开辟数组 O(n) // ../../../../src/main/java/com/dll/array/ShortestUnsortedContinuousSubarray.java package com.dll.array; import java.util.Arrays; import java.util.stream.IntStream; public class ShortestUnsortedContinuousSubarray { class Solution { public int findUnsortedSubarray(int[] nums) { int[] sortedNums = Arrays.stream(nums).sorted().toArray(); int first = IntStream.range(0, sortedNums.length) .filter(index -\u0026gt; sortedNums[index] != nums[index]) .findFirst() .orElse(0); int end = IntStream.range(0, sortedNums.length) .map(index -\u0026gt; sortedNums.length - 1 - index) .filter(index -\u0026gt; sortedNums[index] != nums[index]) .findFirst() .orElse(-1); return end - first + 1; } } } 螺旋矩阵 II 59. spiral-matrix-ii\n// ../../../../src/main/java/com/dll/array/SpiralMatrixII.java package com.dll.array; public class SpiralMatrixII { class Solution { public int[][] generateMatrix(int n) { int[][] matrix = new int[n][n]; int l = 0; int r = n - 1; int t = 0; int b = n - 1; int inc = 1; while (inc \u0026lt;= n * n) { for (int i = l; i \u0026lt;= r; i++) { matrix[t][i] = inc++; } t++; for (int i = t; i \u0026lt;= b; i++) { matrix[i][r] = inc++; } r--; for (int i = r; i \u0026gt;= l; i--) { matrix[b][i] = inc++; } b--; for (int i = b; i \u0026gt;= t; i--) { matrix[i][l] = inc++; } l++; } return matrix; } } } 环形数组是否存在循环 457. circular-array-loop\n当走到 nums[i] 出现正和负时，不是「循环」 循环的步长 \u0026lt;= 1，不是「循环」 当出现重复的 index 时，且重复 index 不是第一个加入的值时，不是「循环」 // ../../../../src/main/java/com/dll/array/CircularArrayLoop.java package com.dll.array; import java.util.TreeSet; public class CircularArrayLoop { class Solution { private boolean isLoop(int[] nums, int index) { TreeSet\u0026lt;Integer\u0026gt; set = new TreeSet\u0026lt;\u0026gt;(); int nextIndex = index; boolean flag = nums[nextIndex] \u0026gt; 0; while (true) { if (nums[nextIndex] \u0026gt; 0 != flag) { return false; } set.add(nextIndex); nextIndex = (nextIndex + nums[nextIndex] + Math.abs(nums[nextIndex]) * nums.length) % nums.length; if (set.contains(nextIndex)) { if (nextIndex != index) { return false; } else if (set.first().intValue() == set.last()) { return false; } break; } } return true; } public boolean circularArrayLoop(int[] nums) { for (int i = 0; i \u0026lt; nums.length; i++) { System.out.println(isLoop(nums, i) + \u0026#34;\u0026#34; + i); if (isLoop(nums, i)) { return true; } } return false; } } } 优美的排列 526. beautiful-arrangement\n回溯法列举全部排列，并判断是否满足需求\n// ../../../../src/main/java/com/dll/array/BeautifulArrangement.java package com.dll.array; import java.util.ArrayList; import java.util.List; import java.util.stream.IntStream; public class BeautifulArrangement { class Solution { private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int N; private int result; private int[] remain(int[] array, int index) { return IntStream.range(0, array.length).filter(i -\u0026gt; index != i).map(i -\u0026gt; array[i]).toArray(); } private boolean isArrangement(int[] array) { for (int i = 0; i \u0026lt; array.length; i++) { if (array[array.length - i - 1] % (array.length - i) != 0 \u0026amp;\u0026amp; (array.length - i) % array[array.length - i - 1] != 0) { return false; } } return true; } private void recursion(int[] array) { if (path.size() \u0026gt; 0 \u0026amp;\u0026amp; path.get(path.size() - 1) % (path.size()) != 0 \u0026amp;\u0026amp; path.size() % path.get(path.size() - 1) != 0) { return; } if (this.path.size() == N) { result++; } for (int i = 0; i \u0026lt; array.length; i++) { this.path.add(array[i]); recursion(this.remain(array, i)); this.path.remove(this.path.size() - 1); } } public int countArrangement(int n) { init(n); this.recursion(IntStream.rangeClosed(1, n).toArray()); return result; } private void init(int n) { this.N = n; } } } 接雨水 42. trapping-rain-water\n// ../../../../src/main/java/com/dll/array/TrappingRainWater42.java package com.dll.array; public class TrappingRainWater42 { class Solution { public int trap(int[] height) { int[] maxLeft = new int[height.length]; int[] maxRight = new int[height.length]; maxLeft[0] = 0; for (int i = 1; i \u0026lt; height.length; i++) { maxLeft[i] = Math.max(maxLeft[i - 1], height[i - 1]); } maxRight[height.length - 1] = 0; for (int j = height.length - 2; j \u0026gt;= 0; j--) { maxRight[j] = Math.max(maxRight[j + 1], height[j + 1]); } int count = 0; for (int z = 0; z \u0026lt; height.length; z++) { int low = Math.min(maxLeft[z], maxRight[z]); if (height[z] \u0026lt; low) { count += low - height[z]; } } return count; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%8D%95%E8%B0%83%E6%A0%88/","title":"单调栈","tags":[],"description":"","content":"每日温度 739. daily-temperatures\n// ../../../../src/main/java/com/dll/monotonicstack/DailyTemperatures.java package com.dll.monotonicstack; import java.util.Stack; public class DailyTemperatures { class Temperature { int value; int index; public Temperature(int value, int index) { this.value = value; this.index = index; } public int getValue() { return value; } public int getIndex() { return index; } } class Solution { public int[] dailyTemperatures(int[] temperatures) { Stack\u0026lt;Temperature\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); int[] result = new int[temperatures.length]; for (int i = 0; i \u0026lt; temperatures.length; i++) { Temperature current = new Temperature(temperatures[i], i); while (!stack.empty()) { Temperature peeked = stack.peek(); if (current.getValue() \u0026gt; peeked.value) { Temperature popped = stack.pop(); result[popped.index] = current.index - popped.index; } else { break; } } stack.push(current); } return result; } } } 下一个更大元素 I 496. next-greater-element-i\n// ../../../../src/main/java/com/dll/monotonicstack/NextGreaterElementI.java package com.dll.monotonicstack; import java.util.Arrays; import java.util.HashMap; import java.util.Map; import java.util.Stack; public class NextGreaterElementI { class Element { int value; int index; public Element(int value, int index) { this.value = value; this.index = index; } public int getValue() { return value; } public int getIndex() { return index; } } class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { Map\u0026lt;Integer, Integer\u0026gt; nextGreaterElements = new HashMap\u0026lt;\u0026gt;(); Stack\u0026lt;Element\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums2.length; i++) { Element current = new Element(nums2[i], i); while (!stack.empty()) { Element peek = stack.peek(); if (current.getValue() \u0026gt; peek.getValue()) { Element pop = stack.pop(); nextGreaterElements.put(pop.getValue(), current.getValue()); } else { break; } } stack.push(current); } return Arrays.stream(nums1) .map(v -\u0026gt; nextGreaterElements.get(v) == null ? -1 : nextGreaterElements.get(v)) .toArray(); } } } 下一个更大元素 II 503. next-greater-element-ii\n// ../../../../src/main/java/com/dll/monotonicstack/NextGreaterElementII.java package com.dll.monotonicstack; import java.util.Arrays; import java.util.Stack; import java.util.stream.IntStream; public class NextGreaterElementII { class Solution { class Element { int value; int index; public Element(int value, int index) { this.value = value; this.index = index; } public int getValue() { return value; } public int getIndex() { return index; } } public int[] nextGreaterElements(int[] nums) { int[] target = IntStream.concat(Arrays.stream(nums), Arrays.stream(nums)).toArray(); int[] result = new int[nums.length * 2]; Arrays.fill(result, -1); Stack\u0026lt;Element\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; target.length; i++) { Element current = new Element(target[i], i); while (!stack.isEmpty()) { Element peek = stack.peek(); if (current.getValue() \u0026gt; peek.getValue()) { Element pop = stack.pop(); result[pop.getIndex()] = current.getValue(); } else { break; } } stack.push(current); } return Arrays.stream(result).limit(nums.length).toArray(); } } } 接雨水 42. trapping-rain-water\n// ../../../../src/main/java/com/dll/monotonicstack/TrappingRainWater.java package com.dll.monotonicstack; import java.util.Stack; public class TrappingRainWater { class Solution { class Elevation { int value; int index; public Elevation(int value, int index) { this.value = value; this.index = index; } public int getValue() { return value; } public int getIndex() { return index; } } public int trap(int[] height) { int traps = 0; Stack\u0026lt;Elevation\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; height.length; i++) { Elevation current = new Elevation(height[i], i); while (!stack.empty()) { Elevation peek = stack.peek(); if (current.getValue() \u0026gt;= peek.getValue()) { Elevation pop = stack.pop(); if (current.getValue() \u0026gt; peek.getValue() \u0026amp;\u0026amp; !stack.empty()) { Elevation peekAfterPop = stack.peek(); int trap = (Math.min(peekAfterPop.getValue(), current.getValue()) - pop.getValue()) * (current.getIndex() - peekAfterPop.getIndex() - 1); traps += trap; } } else { break; } } stack.push(current); } return traps; } } } 柱状图中最大的矩形 84. largest-rectangle-in-histogram\n// ../../../../src/main/java/com/dll/monotonicstack/LargestRectangleInHistogram.java package com.dll.monotonicstack; import java.util.ArrayDeque; import java.util.Arrays; import java.util.Deque; import java.util.stream.IntStream; public class LargestRectangleInHistogram { class Solution { class Rectangle { int height; int index; public Rectangle(int height, int index) { this.height = height; this.index = index; } public int getHeight() { return height; } public int getIndex() { return index; } } public int largestRectangleArea(int[] heights) { Deque\u0026lt;Rectangle\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); int[] heights_ = IntStream.concat(Arrays.stream(heights), Arrays.stream(new int[] {0})).toArray(); stack.push(new Rectangle(0, -1)); int maxArea = 0; for (int i = 0; i \u0026lt; heights_.length; i++) { Rectangle current = new Rectangle(heights_[i], i); while (!stack.isEmpty()) { Rectangle peek = stack.peek(); if (current.getHeight() \u0026lt; peek.getHeight()) { Rectangle pop = stack.pop(); if (!stack.isEmpty()) { Rectangle peekAfterPop = stack.peek(); maxArea = Math.max( maxArea, (current.getIndex() - 1 - peekAfterPop.getIndex()) * pop.getHeight()); } } else { break; } } stack.push(current); } return maxArea; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"字符串","tags":[],"description":"","content":"有效的字母异位词 242. leetcode\n哈希\n// ../../../../src/main/java/com/dll/string/ValidAnagram.java package com.dll.string; import java.util.HashMap; import java.util.Map; public class ValidAnagram { class Solution { private Map\u0026lt;Character, Integer\u0026gt; toCharMap(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); char[] chars = s.toCharArray(); for (char c : chars) { int val = map.getOrDefault(c, 0); map.put(c, val + 1); } return map; } public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } return this.toCharMap(s).equals(this.toCharMap(t)); } } } 查找常用字符 1002. leetcode\n哈希\n// ../../../../src/main/java/com/dll/string/FindCommonCharacters.java package com.dll.string; import java.util.*; import java.util.stream.Collectors; import java.util.stream.IntStream; import java.util.stream.Stream; public class FindCommonCharacters { class Solution { private Map\u0026lt;String, Integer\u0026gt; countWord(String word) { return Arrays.stream(word.split(\u0026#34;\u0026#34;)). collect(Collectors.toMap((w) -\u0026gt; w, (w) -\u0026gt; 1, (oldValue, newValue) -\u0026gt; oldValue + 1)); } public List\u0026lt;String\u0026gt; commonChars(String[] words) { List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Map\u0026lt;String, Integer\u0026gt;\u0026gt; info = Stream.of(words).map(this::countWord).collect(Collectors.toList()); if (info.size() == 0) { return new ArrayList\u0026lt;\u0026gt;(); } Map\u0026lt;String, Integer\u0026gt; firstMap = info.get(0); for (String c : firstMap.keySet()) { int commonCount = firstMap.get(c); for (int i = 1; i \u0026lt; info.size(); i++) { int val = info.get(i).getOrDefault(c, 0); if (val \u0026lt; commonCount) { commonCount = val; } } result.addAll(IntStream.range(0, commonCount).mapToObj(v -\u0026gt; c) .collect(Collectors.toList())); } return result; } } } 反转字符串 344. leetcode\n双指针\n// ../../../../src/main/java/com/dll/string/ReverseString.java package com.dll.string; public class ReverseString { class Solution { private void swap(char[] s, int p, int q) { char temp = s[p]; s[p] = s[q]; s[q] = temp; } public void reverseString(char[] s) { if (s.length \u0026lt;= 1) { return; } for (int i = 0; i \u0026lt; s.length / 2; i++) { int p = i; int q = s.length -1 - i; swap(s, p, q); } } } } 最小覆盖子串 76. leetcode\n滑动窗口\n原字符 ori（s），以及需要包含的字符串 need（t），[l,r) 代表当前窗口，r 右滑直至满足条件，此时通过 l 右滑，可能找到最优解，重复直到结束。\n// ../../../../src/main/java/com/dll/string/MinimumWindowSubstring.java package com.dll.string; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; public class MinimumWindowSubstring { class Solution { public Map\u0026lt;Character, Integer\u0026gt; calc_freq(String s) { Map\u0026lt;Character, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { freq.put(s.charAt(i), freq.getOrDefault(s.charAt(i), 0) + 1); } return freq; } public boolean check(Map\u0026lt;Character, Integer\u0026gt; window_freq, Map\u0026lt;Character, Integer\u0026gt; need_freq) { Iterator\u0026lt;Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; iterator = need_freq.entrySet().iterator(); while (iterator.hasNext()) { Entry\u0026lt;Character, Integer\u0026gt; next = iterator.next(); Character key = next.getKey(); if (!(window_freq.containsKey(key) \u0026amp;\u0026amp; window_freq.get(key) \u0026gt;= next.getValue())) { return false; } } return true; } public String minWindow(String s, String t) { String ori = s; String need = t; int l = 0; int r = 0; String result = \u0026#34;\u0026#34;; Map\u0026lt;Character, Integer\u0026gt; needFreq = calc_freq(need); Map\u0026lt;Character, Integer\u0026gt; window_frep = new HashMap\u0026lt;\u0026gt;(); int endIndex = ori.length() - 1; while (r \u0026lt;= endIndex) { window_frep.put(ori.charAt(r), window_frep.getOrDefault(ori.charAt(r), 0) + 1); while (check(window_frep, needFreq) \u0026amp;\u0026amp; l \u0026lt;= r) { if (\u0026#34;\u0026#34;.equals(result)) { result = ori.substring(l, r + 1); } else { result = ori.substring(l, r + 1).length() \u0026lt; result.length() ? ori.substring(l, r + 1) : result; } window_frep.put(ori.charAt(l), window_frep.getOrDefault(ori.charAt(l), 0) - 1); l++; } r++; } return result; } } } 学生出勤记录 I 551. leetcode\n// ../../../../src/main/java/com/dll/string/StudentAttendanceRecordI.java package com.dll.string; public class StudentAttendanceRecordI { class Solution { private char charAt(String s, int index) { char res = \u0026#39;\\0\u0026#39;; try { res = s.charAt(index); } catch (IndexOutOfBoundsException ignored) { } return res; } public boolean checkRecord(String s) { int absentCount = 0; boolean continuous3DaysLate = false; for (int i = 0; i \u0026lt; s.length(); i++) { if (charAt(s, i) == \u0026#39;A\u0026#39;) { absentCount += 1; } else if ( charAt(s, i) == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; charAt(s, i + 1) == \u0026#39;L\u0026#39; \u0026amp;\u0026amp; charAt(s, i + 2) == \u0026#39;L\u0026#39;) { continuous3DaysLate = true; } if (absentCount \u0026gt;= 2 || continuous3DaysLate) { return false; } } return true; } } } 反转字符串中的元音字母 345. leetcode\n// ../../../../src/main/java/com/dll/string/ReverseVowelsOfAString.java package com.dll.string; import java.util.Arrays; import java.util.List; public class ReverseVowelsOfAString { class Solution { private boolean isVowel(Character c) { List\u0026lt;Character\u0026gt; vowels = Arrays.asList(\u0026#39;a\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;u\u0026#39;); return vowels.contains(c); } private void swap(char[] chars, int l, int r) { char temp = chars[l]; chars[l] = chars[r]; chars[r] = temp; } public String reverseVowels(String s) { char[] chars = s.toCharArray(); int leftIndex = 0; int rightIndex = chars.length - 1; while (leftIndex \u0026lt; rightIndex) { while (leftIndex \u0026lt; rightIndex \u0026amp;\u0026amp; !isVowel(Character.toLowerCase(chars[leftIndex]))) { leftIndex++; } while (leftIndex \u0026lt; rightIndex \u0026amp;\u0026amp; !isVowel(Character.toLowerCase(chars[rightIndex]))) { rightIndex--; } swap(chars, leftIndex, rightIndex); leftIndex++; rightIndex--; } return String.valueOf(chars); } } } 压缩字符串 443. leetcode\n// ../../../../src/main/java/com/dll/string/StringCompression.java package com.dll.string; import java.util.*; public class StringCompression { class Solution { public int[] splitNum(int num) { Deque\u0026lt;Integer\u0026gt; result = new ArrayDeque\u0026lt;\u0026gt;(); while (num != 0) { result.push(num % 10); num /= 10; } return result.stream().mapToInt(i -\u0026gt; i).toArray(); } public int compress(char[] chars) { if (chars.length \u0026lt;= 1) { return chars.length; } int writeIndex = 0; char pre = chars[0]; int count = 1; for (int i = 1; i \u0026lt; chars.length; i++) { if (chars[i] == pre) { count++; } else { writeIndex = updateChars(chars, writeIndex, pre, count); count = 1; } pre = chars[i]; } writeIndex = updateChars(chars, writeIndex, pre, count); return writeIndex; } private int updateChars(char[] chars, int writeIndex, char val, int count) { chars[writeIndex] = val; writeIndex++; if (count != 1) { int[] nums = splitNum(count); int l = 0; while (l \u0026lt; nums.length) { chars[writeIndex++] = Character.forDigit(nums[l], 10); l++; } } return writeIndex; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/","title":"算法分类","tags":[],"description":"","content":""},{"uri":"https://nosugarcoffee.github.io/leetcode/%E5%89%91%E6%8C%87-offer/","title":"剑指 offer","tags":[],"description":"","content":"04. 二维数组中的查找 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer04.java package com.dll.offer; public class Offer04 { class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { int rows; if (matrix == null || (rows = matrix.length) \u0026lt; 1) { return false; } int cols = matrix[0].length; int i = 0; int j = cols - 1; while (i \u0026lt; rows \u0026amp;\u0026amp; j \u0026gt; -1) { int upperRightCorner = matrix[i][j]; if (upperRightCorner == target) { return true; } else if (upperRightCorner \u0026gt; target) { j--; } else { i++; } } return false; } } } 05. 替换空格 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer05.java package com.dll.offer; import java.util.stream.Stream; public class Offer05 { class Solution { public String replaceSpace(String s) { if (s == null) { return \u0026#34;\u0026#34;; } StringBuilder sb = new StringBuilder(); Stream.of(s.split(\u0026#34;\u0026#34;)).forEach(ss -\u0026gt; { if (\u0026#34; \u0026#34;.equals(ss)) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(ss); } }); return sb.toString(); } } } 06. 从尾到头打印链表 leetcode\n递归法 // ../../../../src/main/java/com/dll/offer/Offer06.java package com.dll.offer; import java.util.ArrayList; import java.util.List; public class Offer06 { class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public int[] reversePrint(ListNode head) { return this.recursion(head).stream().mapToInt(i -\u0026gt; i).toArray(); } private List\u0026lt;Integer\u0026gt; recursion(ListNode node) { if (node == null) { return new ArrayList\u0026lt;\u0026gt;(); } List\u0026lt;Integer\u0026gt; list = this.recursion(node.next); list.add(node.val); return list; } } } 07. 重建二叉树 leetcode\n根据前序和中序遍历的规则，前序遍历总是将树分割成 {根 [左子树] [右子树]}，中序遍历则将树分割成 {[左子树] 根 [右子树]}，两者左右子树的成员应该保持一致。\n具体的，当还原前序遍历为 {1,2,4,7,3,5,6,8}，中序遍历为 {4,7,2,1,5,3,8,6} 的树时，需要经历以下步骤:\n根据前序遍历 {1,2,4,7,3,5,6,8} 可得 1 是树的根结点\n结合中序遍历可知左子树中序结果为 {4,7,2}, 前序结果为 {2,4,7}, 右子树中序结果为 {5,3,8,6}, 前序结果为 {3,5,6,8}\n对子树重复上述步骤\n伪代码表示一个流程如下：\npreorder = [1,2,4,7,3,5,6,8] inorder = [4,7,2,1,5,3,8,6] root = preorder[0] # 拆分成两颗子树 subLeftTreeInorder, subRightTreeInorder = splitInorder(root) subLeftTreeInorderlength = subLeftTreeInorder.length() subRightTreeInorderlength = subRightTreeInorder.length() subLeftTreePreorder = preorder[1:subLeftTreeInorderlength] subRightTreePreorder = preorder[subLeftTreeInorderlength:subRightTreeInorderlength] subLeftTreeRoot = subLeftTreePreorder[0] subRightTreeRoot = subRightTreePreorder[0] root.left = subLeftTreeRoot root.right = subRightTreeRoot 经过上述直叙的方式，可以抽象成如下递归体：\nfunc Node rec(preorder, inorder) { root = preorder[0] subLeftTreeInorder, subRightTreeInorder = splitInorder(preorder[0]) subLeftTreeInorderlength = subLeftTreeInorder.length() subRightTreeInorderlength = subRightTreeInorder.length() subLeftTreePreorder = preorder[1:subLeftTreeInorderlength] subRightTreePreorder = preorder[subLeftTreeInorderlength:subRightTreeInorderlength] left = rec(subLeftTreePreorder, subLeftTreeInorder) right = rec(subRightTreePreorder, subRightTreeInorder) root.left = left root.right = right return root } // ../../../../src/main/java/com/dll/offer/Offer07.java package com.dll.offer; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.TreeMap; public class Offer07 { class LevelTreeNode { TreeNode node; int level; public LevelTreeNode(TreeNode node, int level) { this.node = node; this.level = level; } } class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) { return null; } if (preorder.length != inorder.length) { throw new RuntimeException( String.format(\u0026#34;internal error, preorder:%s inorder:%s\u0026#34;, Arrays.toString(preorder), Arrays.toString(inorder))); } int rootValue = preorder[0]; int[][] subTreeInorder = this.splitInorder(inorder, rootValue); int[] leftInorder = subTreeInorder[0]; int[] rightInorder = subTreeInorder[1]; int leftTreeLength = leftInorder.length; int rightTreeLength = rightInorder.length; int[] leftPreorder = new int[]{}; int[] rightPreorder = new int[]{}; if (leftTreeLength \u0026gt; 0) { leftPreorder = Arrays.copyOfRange(preorder, 1, 1 + leftTreeLength); } if (rightTreeLength \u0026gt; 0) { rightPreorder = Arrays.copyOfRange(preorder, 1 + leftTreeLength, preorder.length); } TreeNode left = buildTree(leftPreorder, leftInorder); TreeNode right = buildTree(rightPreorder, rightInorder); TreeNode root = new TreeNode(rootValue); root.left = left; root.right = right; return root; } private int findIndexInArray(int[] array, int root) { int index = 0; for (int value: array) { if (value == root) { return index; } index++; } return -1; } int[][] splitInorder(int[] inorder, int root) { int rootIndex = this.findIndexInArray(inorder, root); if (rootIndex == -1) { return new int[][]{{},{}}; } int[] left = Arrays.copyOfRange(inorder, 0, rootIndex); int[] right = Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length); return new int[][]{left, right}; } // this also can solve problem https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { // map key is level, map value is the list of node value if (root == null) { return new ArrayList\u0026lt;\u0026gt;(new ArrayList\u0026lt;\u0026gt;()); } Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(Comparator.comparingInt(Integer::valueOf)); Deque\u0026lt;LevelTreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(new LevelTreeNode(root, 0)); while (!queue.isEmpty()) { LevelTreeNode n = queue.poll(); List\u0026lt;Integer\u0026gt; list = map.getOrDefault(n.level, new ArrayList\u0026lt;\u0026gt;()); map.put(n.level, list); list.add(n.node.val); if (n.node.left != null) { queue.offer(new LevelTreeNode(n.node.left, n.level + 1)); } if (n.node.right != null) { queue.offer(new LevelTreeNode(n.node.right, n.level + 1)); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } } 09. 用两个栈实现队列 leetcode\n利用两个栈, deQueueStack 以及 enQueueStack\n入队只从 enQueueStack 进 出队只从 deQueueStack 出，deQueueStack 内有元素时直接出队, 无元素时转移全部 enQueueStack 到 deQueueStack // ../../../../src/main/java/com/dll/offer/Offer09.java package com.dll.offer; import java.util.Deque; import java.util.LinkedList; import java.util.NoSuchElementException; public class Offer09 { class CQueue { Deque\u0026lt;Integer\u0026gt; inQueueStack = new LinkedList\u0026lt;\u0026gt;(); Deque\u0026lt;Integer\u0026gt; deQueueStack = new LinkedList\u0026lt;\u0026gt;(); public CQueue() { } public void appendTail(int value) { inQueueStack.push(value); } private int popWrapper() { try { return deQueueStack.pop(); } catch (NoSuchElementException e) { return -1; } } public int deleteHead() { if (deQueueStack.isEmpty()) { while (!inQueueStack.isEmpty()) { deQueueStack.push(inQueueStack.pop()); } } return popWrapper(); } } } 10- I. 斐波那契数列 leetcode\n直接递归会超时，所以加了个简易的 cache\n// ../../../../src/main/java/com/dll/offer/Offer10I.java package com.dll.offer; import java.util.HashMap; import java.util.Map; public class Offer10I { class Solution { Map\u0026lt;Integer, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public int fib(int n) { if (cache.containsKey(n)) { return cache.get(n); } if (n \u0026lt; 2) { return n; } int val = (fib(n - 1) + fib(n - 2)) % 1000000007; cache.put(n, val); return val; } } } 10- II. 青蛙跳台阶问题 leetcode\n斐波那契数列包了一层背景，原理一样\n// ../../../../src/main/java/com/dll/offer/Offer10II.java package com.dll.offer; import java.util.HashMap; import java.util.Map; public class Offer10II { class Solution { Map\u0026lt;Integer, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); private int recu(int n) { if (cache.containsKey(n)) { return cache.get(n); } if (n == 0 || n == 1) { return 1; } int val = (recu(n - 1) + recu(n - 2)) % 1000000007; cache.put(n, val); return val; } public int numWays(int n) { return recu(n); } } } 11. 旋转数组的最小数字 这题直接用暴力法解了，因为个人觉得题目没什么太大实际意义 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer11.java package com.dll.offer; public class Offer11 { class Solution { public int minArray(int[] numbers) { if (numbers == null || numbers.length \u0026lt; 1) { throw new RuntimeException(); } int min = numbers[0]; for (int i = 1; i \u0026lt; numbers.length; i++) { if (numbers[i] \u0026lt; numbers[i - 1]) { min = numbers[i]; break; } } return min; } } } 13. 机器人的运动范围 leetcode\n这题有坑，开始以为按照如下代码可解，提交后一直不能 ac\nclass Solution { int calc(int num) { int sum = 0; while(num != 0) { sum += num % 10; num /= 10; } return sum; } public int movingCount(int m, int n, int k) { int counter = 0; for(int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if ((calc(i) + calc(j)) \u0026lt;= k ) { counter++; } } } return counter; } } 翻看评论才知道，有如下二维数组，当 k = 8 时，机器人无法从第九行或者第九列跨过去\n0 1 2 3 4 5 6 7 8 9 10 0 可 可 可 可 可 可 可 可 可 不 可 1 可 可 可 可 可 可 可 可 不 不 可 2 可 可 可 可 可 可 可 不 不 不 可 3 可 可 可 可 可 可 不 不 不 不 可 4 可 可 可 可 可 不 不 不 不 不 可 5 可 可 可 可 不 不 不 不 不 不 可 6 可 可 可 不 不 不 不 不 不 不 可 7 可 可 不 不 不 不 不 不 不 不 可 8 可 不 不 不 不 不 不 不 不 不 不 9 不 不 不 不 不 不 不 不 不 不 不 10可 可 可 可 可 可 可 可 可 可 不 （可为可到达的，不为不可到达的） 代码：\n// ../../../../src/main/java/com/dll/offer/Offer13.java package com.dll.offer; public class Offer13 { class Solution { int mLen; int nLen; int k; int[][] visited; private int calc(int num) { int sum = 0; while(num != 0) { sum += num % 10; num /= 10; } return sum; } public int dfs(int i, int j) { if ( i \u0026gt;= mLen || j \u0026gt;= nLen) { return 0; } if (visited[i][j] == 1) { return 0; } visited[i][j] = 1; if (calc(i) + calc(j) \u0026gt; this.k) { return 0; } return 1 + this.dfs(i + 1, j) + this.dfs(i, j + 1); } private void init(int m, int n, int k) { this.mLen = m; this.nLen = n; this.k = k; this.visited = new int[m][n]; } public int movingCount(int m, int n, int k) { this.init(m, n, k); return this.dfs(0, 0); } } } 18. 删除链表的节点 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer18.java package com.dll.offer; public class Offer18 { class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode pre = null; ListNode cur = head; while (cur != null) { if (cur.val == val) { if (pre == null) { cur = cur.next; head = cur; } else { pre.next = cur.next; cur = cur.next; } } else { pre = cur; cur = cur.next; } } return head; } } } 24. 反转链表 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer24.java package com.dll.offer; public class Offer24 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; ListNode next = null; while(current != null) { next = current.next; current.next = prev; prev = current; current = next; } return prev; } } } 25. 合并两个排序的链表 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer25.java package com.dll.offer; public class Offer25 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode p1 = l1; ListNode p2 = l2; ListNode dummy = new ListNode(-1); ListNode last = dummy; while(p1 != null \u0026amp;\u0026amp; p2 != null) { if ( p1.val \u0026gt; p2.val) { last.next = p2; p2 = p2.next; } else { last.next = p1; p1 = p1.next; } last = last.next; } if (p1 != null) { last.next = p1; } if (p2 != null) { last.next = p2; } return dummy.next; } } } 52. 两个链表的第一个公共节点 leetcode\n要比较的是 node 是否相等，而不是 value 是否相等。 由于是单向链表，即重合后一定是 “Y” 型，而不是 “X” 型，尾部长度一致。 使链表 A 和链表 B 末尾对齐，同时遍历，出现相同结点则直接返回，直到遍历至末尾都没有相同结点则返回 null。 时空复杂度\n时间复杂度: O(len(A) + len(B))) 空间复杂度：O(1) // ../../../../src/main/java/com/dll/offer/Offer52.java package com.dll.offer; public class Offer52 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode getIntersectionNOde(ListNode headA, ListNode headB) { ListNode pa = headA; ListNode pb = headB; int lenA = 0; int lenB = 0; while(pa != null) { lenA++; pa = pa.next; } while(pb != null) { lenB++; pb = pb.next; } int distance = Math.abs(lenA - lenB); ListNode pLong = headA; ListNode pShort = headB; if (lenB \u0026gt; lenA) { pLong = headB; pShort = headA; } while(distance-- \u0026gt; 0) { pLong = pLong.next; } while(pLong != null) { if (pLong == pShort) { return pLong; } pLong = pLong.next; pShort = pShort.next; } return null; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E9%93%BE%E8%A1%A8/","title":"链表","tags":[],"description":"","content":"两数相加 @leetcode 2 各个位置上的结点相加并需要考虑进位\n// ../../../../src/main/java/com/dll/linkedList/AddTwoNumbers2.java package com.dll.linkedList; public class AddTwoNumbers2 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = new ListNode(-1); ListNode last = head; int pre = 0; while (l1 != null || l2 != null) { int l1Val = l1 == null ? 0 : l1.val; int l2Val = l2 == null ? 0 : l2.val; last.next = new ListNode((l1Val + l2Val + pre) % 10); pre = (l1Val + l2Val + pre) / 10; last = last.next; if (l1 != null) { l1 = l1.next; } if (l2 != null) { l2 = l2.next; } } // 注意此处的进位 if (pre != 0) { last.next = new ListNode(pre); last = last.next; } last.next = null; return head.next; } } } 删除链表的倒数第 N 个结点 @leetcode 19 使用双指针，cur 指向当前结点，pren 指向 cur 的第前 n 个结点，当 cur 走到 null 时，pren 即为需要删除的结点\n// ../../../../src/main/java/com/dll/linkedList/RemoveNthNodeFromEndOfList19.java package com.dll.linkedList; public class RemoveNthNodeFromEndOfList19 { public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1, head); ListNode p = head; ListNode preOfPren = null; ListNode pren = null; while (p != null \u0026amp;\u0026amp; n \u0026gt; 0) { n--; p = p.next; } if (n \u0026gt; 0) { return null; } preOfPren = dummy; pren = head; while (p != null) { preOfPren = pren; pren = pren.next; p = p.next; } preOfPren.next = pren.next; return dummy.next; } } } 删除排序链表中的重复元素 II @leetcode 82 // ../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedListII82.java package com.dll.linkedList; public class RemoveDuplicatesFromSortedListII82 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(); ListNode tail = dummy; ListNode cur = head; while (cur != null) { ListNode next = cur.next; if (next == null) { tail.next = cur; tail = tail.next; cur = cur.next; } else if (cur.val != next.val) { tail.next = cur; tail = tail.next; cur = cur.next; } else { cur = findNextUnDuplicatedNodeWithHead(cur); } } tail.next = null; return dummy.next; } /** * find the node closest to the head with different value example: 1-\u0026gt;2-\u0026gt;2 return 2 example: * 2-\u0026gt;2-\u0026gt;3 return 3 example: 1-\u0026gt;1-\u0026gt;1 return null example: null return null * * @param head of the list * @return the node closest to the head with different value or null */ ListNode findNextUnDuplicatedNodeWithHead(ListNode head) { if (head == null || head.next == null) { return null; } if (head.val != head.next.val) { return head.next; } return findNextUnDuplicatedNodeWithHead(head.next); } } } 删除排序链表中的重复元素 @leetcode 83 // ../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedList83.java package com.dll.linkedList; public class RemoveDuplicatesFromSortedList83 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head.next; while (cur != null) { if (cur.val == pre.val) { cur = cur.next; pre.next = cur; } else { pre = cur; cur = cur.next; } } return head; } } } 移除链表元素 @leetcode 203 增加一个 dummy 结点使删除头结点和中间结点的逻辑一致 p 总是指向当前需要做逻辑判断的结点， pre 则为 p 的前一个结点 p 指向的结点 val 与给定一致时，删除 p 结点，即 pre.next = p.next pre 与 p 的维护：当结点删除，下一轮的 pre 不需要变动，p = p.next，否则一直保持 pre 和 p 的前进 // ../../../../src/main/java/com/dll/linkedList/RemoveLinkedListElements203.java package com.dll.linkedList; public class RemoveLinkedListElements203 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode p = head; while (p != null) { if (p.val == val) { pre.next = p.next; } else { pre = p; } p = p.next; } return dummy.next; } } } 环形链表 II @leetcode 142 哈希法 // ../../../../src/main/java/com/dll/linkedList/LinkedListCycleIIHash.java package com.dll.linkedList; import java.util.HashSet; import java.util.Set; public class LinkedListCycleIIHash { class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { private Set\u0026lt;ListNode\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); public ListNode detectCycle(ListNode head) { ListNode p = head; while (p != null) { if (set.contains(p)) { return p; } set.add(p); p = p.next; } return null; } } } 快慢指针 该思路比较有趣, 具体如下: 若存在环时, 遍历永不结束。慢指针每次走 1 步, 快指针每次走 2 步, 成环时快指针总是能追上慢指针。那么如何知道入口点, 由已知关系得:\n快指针路径长 = 2 倍慢指针的路径 = n 圈路径长 + a + b 2(a+b) = a+b+(b+c)*n a+b = (b+c)n a = (b+c)n-b a = (b+c)(n-1)+c 从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离 在表头新建指针与 slow 同步移动, 相交处即为入口点\n// ../../../../src/main/java/com/dll/linkedList/LinkedListCycleIIDoublePoint.java package com.dll.linkedList; public class LinkedListCycleIIDoublePoint { class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow, fast, find; try { find = head; slow = head.next; fast = slow.next; } catch (NullPointerException e) { return null; } while (fast != null) { if (fast == slow) { while (find != slow) { find = find.next; slow = slow.next; } return find; } fast = fast.next; slow = slow.next; if (fast != null) { fast = fast.next; } else { return null; } } return null; } } } 两数相加 II @leetcode 445 // ../../../../src/main/java/com/dll/linkedList/AddTwoNumbersII445.java package com.dll.linkedList; import java.util.ArrayDeque; public class AddTwoNumbersII445 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { private ArrayDeque\u0026lt;ListNode\u0026gt; pushToStack(ListNode l) { ArrayDeque\u0026lt;ListNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); while (l != null) { stack.push(l); l = l.next; } return stack; } public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ArrayDeque\u0026lt;ListNode\u0026gt; stack1 = pushToStack(l1); ArrayDeque\u0026lt;ListNode\u0026gt; stack2 = pushToStack(l2); ListNode head = new ListNode(-1); head.next = null; int carry = 0; while (!stack1.isEmpty() \u0026amp;\u0026amp; !stack2.isEmpty()) { int s1 = stack1.pop().val; int s2 = stack2.pop().val; head.next = new ListNode((s1 + s2 + carry) % 10, head.next); carry = (s1 + s2 + carry) / 10; } ArrayDeque\u0026lt;ListNode\u0026gt; stack = stack1.isEmpty() ? stack2 : stack1; while (!stack.isEmpty()) { int val = stack.pop().val; head.next = new ListNode((val + carry) % 10, head.next); carry = (val + carry) / 10; } if (carry \u0026gt; 0) { head.next = new ListNode(carry, head.next); } return head.next; } } } 设计链表 @leetcode 707 维护 dummy 为链表的初始结点，维护 tail 指针指向链表末尾非 null 结点（初始化时 tail = dummy），维护 len 代表当前链表的长度（不计 dummy） 何时更新 tail 指针？ addAtHead(val) 或 addAtIndex(-1, val) 且插入的结点为头结点，更新 tail 为当前插入的结点 deleteAtIndex(index) index 为链表的尾结点，更新 tail 为删除结点的 previous 结点 // ../../../../src/main/java/com/dll/linkedList/DesignLinkedList707.java package com.dll.linkedList; public class DesignLinkedList707 { class MyLinkedList { private Node dummy; // tail refs to last one of the list private Node tail; private int len; /** Initialize your data structure here. */ public MyLinkedList() { dummy = new Node(-1); tail = dummy; } /** * Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ public int get(int index) { Node p = dummy.next; if (index \u0026lt; 0 || index \u0026gt;= len) { return -1; } while (index \u0026gt; 0) { p = p.next; index--; } return p.val; } /** * Add a node of value val before the first element of the linked list. After the insertion, the * new node will be the first node of the linked list. */ public void addAtHead(int val) { Node pre = dummy; Node p = dummy.next; pre.next = new Node(val, p); len++; if (p == null) { tail = pre.next; } } /** Append a node of value val to the last element of the linked list. */ public void addAtTail(int val) { Node node = new Node(val); tail.next = node; tail = node; len++; } /** * Add a node of value val before the index-th node in the linked list. If index equals to the * length of linked list, the node will be appended to the end of linked list. If index is * greater than the length, the node will not be inserted. */ public void addAtIndex(int index, int val) { Node pre = dummy; Node p = dummy.next; if (index \u0026lt; 0) { this.addAtHead(val); return; } if (index \u0026gt; len) { return; } if (index == len) { this.addAtTail(val); return; } while (index \u0026gt; 0) { index--; pre = p; p = p.next; } pre.next = new Node(val, p); len++; } /** Delete the index-th node in the linked list, if the index is valid. */ public void deleteAtIndex(int index) { Node p = dummy.next; Node pre = dummy; if (index \u0026lt; 0 || index \u0026gt;= len) { return; } while (index \u0026gt; 0) { index--; pre = p; p = p.next; } pre.next = p.next; len--; if (p.next == null) { tail = pre; } } @Override public String toString() { Node p = this.dummy.next; StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;[\u0026#34;); while (p != null) { sb.append(p.val + \u0026#34;-\u0026gt;\u0026#34;); p = p.next; } if (tail == null) { sb.append(\u0026#34;null] tail: null\u0026#34;); } else { sb.append(\u0026#34;null] tail:\u0026#34; + tail.val); } return sb.toString(); } class Node { private int val; private Node next; public Node(int val) { this(val, null); } public Node(int val, Node next) { this.val = val; this.next = next; } } } } 合并 K 个升序链表 @leetcode 23 合并 2 个升序链表的逻辑，在其基础上扩展合并 K 个\n// ../../../../src/main/java/com/dll/linkedList/MergeKSortedLists23.java package com.dll.linkedList; class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } public class MergeKSortedLists23 { class Solution { ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode head = new ListNode(-1, null); ListNode last = head; while (l1 != null \u0026amp;\u0026amp; l2 != null) { last.next = new ListNode(Math.min(l1.val, l2.val), null); last = last.next; if (l1.val \u0026lt;= l2.val) { l1 = l1.next; } else { l2 = l2.next; } } if (l1 == null) { last.next = l2; } else { last.next = l1; } return removeHeadIfExist(head); } private ListNode removeHeadIfExist(ListNode head) { return (head.val == -1) ? head.next : head; } public ListNode mergeKLists(ListNode[] lists) { ListNode previousMerged = null; for (ListNode list : lists) { previousMerged = mergeTwoLists(previousMerged, list); } return previousMerged; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/lru%E7%BC%93%E5%AD%98/","title":"LRU 缓存","tags":[],"description":"","content":"LRU 缓存机制 146 // ../../../../../src/main/java/com/dll/leetcode/LRUCache146.java package com.dll.leetcode; import java.util.HashMap; import java.util.Map; public class LRUCache146 { class DoubleLinkedList { private Map\u0026lt;Integer, Node\u0026gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap\u0026lt;\u0026gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.key = key; this.prev = prev; this.value = value; this.next = next; } } private boolean containsKey(int key) { return this.map.containsKey(key); } public Node get(int key) { return this.map.getOrDefault(key, null); } public void delete(Node node) { Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; this.map.remove(node.key); this.size--; } private Node addFirst(int key, int value) { Node node = new Node(head, key, value, head.next); head.next.prev = node; head.next = node; this.size++; this.map.put(key, node); return node; } private Node deleteLast() { Node deletedPrev = tail.prev.prev; Node deleted = deletedPrev.next; deletedPrev.next = tail; tail.prev = deletedPrev; this.map.remove(deleted.key); return deleted; } } private DoubleLinkedList list = new DoubleLinkedList(); private int capacity; public LRUCache146(int capacity) { if (capacity \u0026lt;= 0) { throw new RuntimeException(); } this.capacity = capacity; } /** * get value by key from cache * @param key key of cache * @return value of key */ public int get(int key) { DoubleLinkedList.Node node = list.get(key); if (node == null) { return -1; } list.delete(node); list.addFirst(node.key, node.value); return node.value; } /** * put key and value to cache * @param key key of cache * @param value value of key */ public void put(int key, int value) { // 1. exist in map -\u0026gt; remove(value) \u0026amp; push(value) // 2. don\u0026#39;t exist in map -\u0026gt; deque is full -\u0026gt; removeLast \u0026amp; push(value) // 3. don\u0026#39;t exist in map -\u0026gt; deque is empty -\u0026gt; push(value) if (list.containsKey(key)) { list.delete(list.get(key)); } else { if (list.getSize() \u0026gt;= this.capacity) { list.deleteLast(); } } list.addFirst(key, value); } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%9B%9E%E6%BA%AF/","title":"回溯","tags":[],"description":"","content":"回溯属于暴力解法，常用于多层 for 表达不了的场景，比如能用两层 for 解决『二数之和』 ，三层 for 解决『三数之后』 ，但是无法解决『n 数之和』 。\n77. 组合 leetcode\n// ../../../../src/main/java/com/dll/backtracing/Combinations.java package com.dll.backtracing; import java.util.ArrayList; import java.util.List; public class Combinations { class Solution { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public void backTracing(int startIndex, int n, int k) { if (path.size() == k) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = startIndex; i \u0026lt;= n - (k - path.size() - 1); i++) { path.add(i); backTracing(i + 1, n, k); path.remove(path.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { backTracing(1, n, k); return result; } } } 216. 组合总和 III leetcode\n// ../../../../src/main/java/com/dll/backtracing/CombinationSumIII.java package com.dll.backtracing; import java.util.ArrayList; import java.util.List; public class CombinationSumIII { class Solution { List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); int sum(List\u0026lt;Integer\u0026gt; path) { return path.stream().reduce(0, Integer::sum); } void backTracing(int k, int n, int startIndex) { int total = sum(path); if (total == n \u0026amp;\u0026amp; path.size() == k) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } else if (total \u0026gt; n || path.size() \u0026gt; k) { return; } for (int i = startIndex; i \u0026lt;= 9 - (k - path.size()) + 1; i++) { path.add(i); backTracing(k, n, startIndex + 1); path.remove(path.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { backTracing(k, n, 1); return result; } } } 17. 电话号码的字母组合 leetcode\n// ../../../../src/main/java/com/dll/backtracing/LetterCombinationsOfAPhoneNumber.java package com.dll.backtracing; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class LetterCombinationsOfAPhoneNumber { class Solution { private final Map\u0026lt;Integer, Character[]\u0026gt; numAndLetters = mappingNumAndLetters(); private final List\u0026lt;Character\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private final List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Map\u0026lt;Integer, Character[]\u0026gt; mappingNumAndLetters() { Map\u0026lt;Integer, Character[]\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); char ch = \u0026#39;a\u0026#39;; for (int i = 2; i \u0026lt;= 9; i++) { int loop = (i == 7 || i == 9) ? 4 : 3; List\u0026lt;Character\u0026gt; letters = new ArrayList\u0026lt;\u0026gt;(); while (ch \u0026lt;= \u0026#39;z\u0026#39;) { loop--; letters.add(ch); ch++; if (loop \u0026lt;= 0) { map.put(i, letters.toArray(new Character[0])); break; } } } return map; } public void backTracing(String digits, int index) { if (path.size() \u0026gt;= digits.length()) { if (path.size() == digits.length()) { StringBuilder sb = new StringBuilder(); path.forEach(sb::append); // edge case: digits = \u0026#34;\u0026#34; if (!sb.toString().isEmpty()) { result.add(sb.toString()); } } return; } Character[] candidates = numAndLetters.get(Character.getNumericValue(digits.charAt(index))); for (char candidate : candidates) { path.add(candidate); backTracing(digits, index + 1); path.remove(path.size() - 1); } } public List\u0026lt;String\u0026gt; letterCombinations(String digits) { backTracing(digits, 0); return result; } } } 131. 分割回文串 leetcode\n// ../../../../src/main/java/com/dll/backtracing/PalindromePartitioning.java package com.dll.backtracing; import java.util.ArrayList; import java.util.List; public class PalindromePartitioning { class Solution { private List\u0026lt;String\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); public boolean isPalindrome(String text) { char[] letters = text.toCharArray(); int i = 0; while (i \u0026lt; letters.length / 2) { if (letters[i] != letters[letters.length - 1 - i]) { return false; } i++; } return true; } public void backTracing(String leftover) { if (leftover.isEmpty() \u0026amp;\u0026amp; path.stream().allMatch(this::isPalindrome)) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int splitIndex = 1; splitIndex \u0026lt;= leftover.length(); splitIndex++) { String left = leftover.substring(0, splitIndex); String right = leftover.substring(splitIndex); path.add(left); backTracing(right); path.remove(path.size() - 1); } } public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; partition(String s) { backTracing(s); return result; } } } 93. 复原 IP 地址 leetcode\n// ../../../../src/main/java/com/dll/backtracing/RestoreIpAddresses.java package com.dll.backtracing; import java.util.ArrayList; import java.util.List; public class RestoreIpAddresses { class Solution { private final List\u0026lt;String\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private final List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private int stringLength = 0; private int visitLength = 0; private void backTracing(String s) { if (path.size() \u0026gt; 4) { return; } else if (path.size() == 4 \u0026amp;\u0026amp; visitLength == stringLength) { result.add(String.join(\u0026#34;.\u0026#34;, path)); return; } for (int splitIndex = 1; splitIndex \u0026lt;= s.length(); splitIndex++) { String left = s.substring(0, splitIndex); String right = s.substring(splitIndex); if (isIllegal(left)) { return; } path.add(left); visitLength += left.length(); backTracing(right); path.remove(path.size() - 1); visitLength -= left.length(); } } private boolean isIllegal(String text) { return text.startsWith(\u0026#34;0\u0026#34;) \u0026amp;\u0026amp; text.length() \u0026gt;= 2 || Integer.parseInt(text) \u0026gt; 255; } public List\u0026lt;String\u0026gt; restoreIpAddresses(String s) { if (s.length() \u0026lt; 4 || s.length() \u0026gt; 12) { return new ArrayList\u0026lt;\u0026gt;(); } stringLength = s.length(); backTracing(s); return result; } } } 78. 子集 leetcode\n// ../../../../src/main/java/com/dll/backtracing/Subsets.java package com.dll.backtracing; import java.util.ArrayList; import java.util.List; public class Subsets { class Solution { private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private void backTracing(int[] nums, int start) { for (int i = start; i \u0026lt; nums.length; i++) { path.add(nums[i]); result.add(new ArrayList\u0026lt;\u0026gt;(path)); backTracing(nums, i + 1); path.remove(path.size() -1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); backTracing(nums, 0); return result; } } } 90. 子集 II leetcode\n// ../../../../src/main/java/com/dll/backtracing/SubsetsII.java package com.dll.backtracing; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class SubsetsII { class Solution { private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private void backTracing(int[] nums, int[] used, int start) { for (int i = start; i \u0026lt; nums.length; i++) { if (i \u0026gt;= 1 \u0026amp;\u0026amp; nums[i] == nums[i - 1] \u0026amp;\u0026amp; used[i - 1] == 0) { continue; } path.add(nums[i]); used[i] = 1; result.add(new ArrayList\u0026lt;\u0026gt;(path)); backTracing(nums, used, i + 1); path.remove(path.size() - 1); used[i] = 0; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); int[] used = new int[nums.length]; Arrays.sort(nums); backTracing(nums, used, 0); return result; } } } 491. 递增子序列 leetcode\n// ../../../../src/main/java/com/dll/backtracing/IncreasingSubsequences.java package com.dll.backtracing; import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class IncreasingSubsequences { class Solution { private final List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private final List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private void backTracing(int[] nums, int startIndex) { Map\u0026lt;Integer, Integer\u0026gt; used = new HashMap(); for (int i = startIndex; i \u0026lt; nums.length; i++) { if (used.containsKey(nums[i]) || (path.size() \u0026gt; 0) \u0026amp;\u0026amp; path.get(path.size() - 1) \u0026gt; nums[i]) { continue; } used.put(nums[i], 1); path.add(nums[i]); if (path.size() \u0026gt;= 2) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); } backTracing(nums, i + 1); path.remove(path.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; findSubsequences(int[] nums) { backTracing(nums, 0); return result; } } } 46. 全排列 leetcode\n// ../../../../src/main/java/com/dll/backtracing/Permutations.java package com.dll.backtracing; import java.util.ArrayList; import java.util.List; public class Permutations { class Solution { private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private void backTracing(int[] nums, boolean[] visited) { if (path.size() == nums.length) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; nums.length; i++) { if (visited[i]) { continue; } path.add(nums[i]); visited[i] = true; backTracing(nums, visited); path.remove(path.size() - 1); visited[i] = false; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; permute(int[] nums) { backTracing(nums, new boolean[nums.length]); return result; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","title":"动态规划","tags":[],"description":"","content":"斐波那契数 509. leetcode\n// ../../../../src/main/java/com/dll/dp/FibonacciNumber.java package com.dll.dp; public class FibonacciNumber { class Solution { public int fib(int n) { if (n \u0026lt; 2) { return n; } int[] dp = new int[2]; dp[1] = 1; for (int i = 2; i \u0026lt;= n; i++) { int fibN = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = fibN; } return dp[1]; } } } 爬楼梯 70. leetcode\n// ../../../../src/main/java/com/dll/dp/ClimbingStairs.java package com.dll.dp; public class ClimbingStairs { class Solution { public int climbStairs(int n) { if (n \u0026lt;= 2) { return n; } int[] dp = new int[n + 1]; dp[1] = 1; dp[2] = 2; for (int i = 3; i \u0026lt;= n; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n]; } } } 使用最小花费爬楼梯 746. leetcode\n// ../../../../src/main/java/com/dll/dp/MinCostClimbingStairs.java package com.dll.dp; public class MinCostClimbingStairs { class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length]; dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i \u0026lt; cost.length; i++) { dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i]; } return Math.min(dp[cost.length - 1], dp[cost.length - 2]); } } } 不同路径 62. leetcode\n// ../../../../src/main/java/com/dll/dp/UniquePaths.java package com.dll.dp; import java.util.Arrays; public class UniquePaths { class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m + 1][n + 1]; Arrays.stream(dp).forEach(item -\u0026gt; Arrays.fill(item, 1)); for (int i = 2; i \u0026lt;= m; i++) { for (int j = 2; j \u0026lt;= n; j++) { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } return dp[m][n]; } } } 不同路径 II 63. leetcode\n// ../../../../src/main/java/com/dll/dp/UniquePathsII.java package com.dll.dp; public class UniquePathsII { class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u0026lt;= m; i++) { for (int j = 1; j \u0026lt;= n; j++) { if (obstacleGrid[i - 1][j - 1] == 1) { dp[i][j] = 0; } else if (i == 1 \u0026amp;\u0026amp; j == 1) { dp[i][j] = 1; } else { dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m][n]; } } } 整数拆分 343. leetcode\n// ../../../../src/main/java/com/dll/dp/IntegerBreak.java package com.dll.dp; public class IntegerBreak { class Solution { public int integerBreak(int n) { int[] dp = new int[n + 1]; for (int i = 2; i \u0026lt;= n; i++) { for (int j = i - 1; j \u0026gt; 0; j--) { dp[i] = Math.max(dp[i], Math.max(j * dp[i - j], j * (i - j))); } } return dp[n]; } } } 不同的二叉搜索树 96. leetcode\n// ../../../../src/main/java/com/dll/dp/UniqueBinarySearchTrees.java package com.dll.dp; public class UniqueBinarySearchTrees { class Solution { public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; for (int i = 1; i \u0026lt;= n; i++) { for (int j = 1; j \u0026lt;= i; j++) { dp[i] += dp[j - 1] * dp[i - (j - 1) - 1]; } } return dp[n]; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%9B%BE/","title":"图","tags":[],"description":"","content":"最短路径 网络延迟时间 743. leetcode\n由题意知需要求源结点（k）到其余结点（vi）的最短路径中的最大值， 即 max(min(k, v1), min(k, v2) \u0026hellip; min(k, vn))， 参考 Dijkstra 算法可以解决，需要借助三个辅助数组， set[] 标记当前已知的最短路径顶点集合，dist[] 当前已知的最短路径，path[] 当前最短路径顶点的前置顶点\n// ../../../../src/main/java/com/dll/graph/NetworkDelayTime.java package com.dll.graph; import java.util.Arrays; public class NetworkDelayTime { class Solution { // 1 :对应结点已经得到最短路径，0 :没有 private int[] set; // Int.MAX / 2: 不可达, 其余：可达 private int[] dist; private int[] path; private int[][] edges; private int findShortestInDist(int[] dist, int[] set) { int minIndex = -1; int min = Integer.MAX_VALUE / 2; for (int i = 1; i \u0026lt; dist.length; i++) { if (set[i] != 1 \u0026amp;\u0026amp; dist[i] \u0026lt; min) { min = dist[i]; minIndex = i; } } return minIndex; } // 源结点是否都全部找到到其他结点的最短路径 private boolean isFindAllShortestPath(int[] set) { return !Arrays.stream(set).filter(v -\u0026gt; v != 1).findAny().isPresent(); } private int findLongestDist(int[] dist, int[] set) { int longest = -1; for (int i = 1; i \u0026lt; dist.length; i++) { if (set[i] == 1 \u0026amp;\u0026amp; dist[i] \u0026gt; longest) { longest = dist[i]; } } return longest; } private void dijkstraInit(int[][] times, int n, int k) { int[][] edges = new int[n + 1][n + 1]; for (int i = 0; i \u0026lt; edges.length; i++) { Arrays.fill(edges[i], Integer.MAX_VALUE / 2); } for (int i = 0; i \u0026lt; times.length; i++) { edges[times[i][0]][times[i][1]] = times[i][2]; } int[] set = new int[n + 1]; int[] dist = new int[n + 1]; int[] path = new int[n + 1]; Arrays.fill(dist, Integer.MAX_VALUE / 2); Arrays.fill(path, -1); dist[k] = 0; set[0] = 1; this.edges = edges; this.set = set; this.dist = dist; this.path = path; } public int networkDelayTime(int[][] times, int n, int k) { dijkstraInit(times, n, k); for (int i = 0; i \u0026lt; n; i++) { int minIndex = findShortestInDist(dist, set); System.out.println(minIndex); if (minIndex == -1) { break; } set[minIndex] = 1; for (int j = 1; j \u0026lt;= n; j++) { if (set[j] == 0) { if (dist[minIndex] + edges[minIndex][j] \u0026lt; dist[j]) { dist[j] = dist[minIndex] + edges[minIndex][j]; path[j] = minIndex; } } } } return isFindAllShortestPath(set) \u0026amp;\u0026amp; findLongestDist(dist, set) != 0 ? findLongestDist(dist, set) : -1; } } } 找到最终的安全状态 802. leetcode\n深度遍历图的各个结点，并记录下遍历的路径，遇到重复（呈环）则表示深度遍历路径上的每个结点都不是「安全」结点\n其中 graph[ori] = new int[]{} 很关键，可以减少下次遍历到该结点的深度 unsafe 用于记录当前环内的结点，环内的结点不可能是「安全」的 // ../../../../src/main/java/com/dll/graph/FindEventualSafeStates.java package com.dll.graph; import java.util.ArrayList; import java.util.HashSet; import java.util.List; import java.util.Set; public class FindEventualSafeStates { class Solution { private List\u0026lt;Integer\u0026gt; safe = new ArrayList\u0026lt;\u0026gt;(); private Set\u0026lt;Integer\u0026gt; unSafe = new HashSet\u0026lt;\u0026gt;(); private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); public List\u0026lt;Integer\u0026gt; eventualSafeNodes(int[][] graph) { for (int i = 0; i \u0026lt; graph.length; i++) { if (unSafe.contains(i)) { continue; } if (isSafe(graph, i)) { safe.add(i); } } return safe; } private boolean isSafe(int[][] graph, int ori) { if (path.contains(ori)) { unSafe.addAll(path); return false; } path.add(ori); for (int node : graph[ori]) { if (!isSafe(graph, node)) { path.remove(path.size() - 1); return false; } } graph[ori] = new int[]{}; path.remove(path.size() - 1); return true; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"多线程","tags":[],"description":"","content":"交替打印FooBar 1115 利用 AtomicBoolean 来互斥的访问临界资源\n// ../../../../../src/main/java/com/dll/multithreads/PrintFoobarAlternately.java package com.dll.multithreads; import java.util.concurrent.atomic.AtomicBoolean; public class PrintFoobarAlternately { class FooBar { private int n; private AtomicBoolean flag = new AtomicBoolean(true); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { while (!flag.get()) { Thread.yield(); } // printFoo.run() outputs \u0026#34;foo\u0026#34;. Do not change or remove this line. printFoo.run(); flag.set(false); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { while (flag.get()) { Thread.yield(); } // printBar.run() outputs \u0026#34;bar\u0026#34;. Do not change or remove this line. printBar.run(); flag.set(true); } } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F/","title":"排序","tags":[],"description":"","content":"冒泡排序 // ../../../../../src/main/java/com/dll/sort/BubbleSort.java package com.dll.sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { this.swap(arr, j, j + 1); swapped = true; } } if (!swapped) { break; } } } } 选择排序 // ../../../../../src/main/java/com/dll/sort/SelectionSort.java package com.dll.sort; public class SelectionSort { private void swap(int[] arr, int first, int second) { int temp = arr[first]; arr[first] = arr[second]; arr[second] = temp; } public void sort(int[] arr) { for (int i=0; i \u0026lt; arr.length-1; i++) { int minIndex = i; for (int j=i+1; j \u0026lt; arr.length; j++) { if(arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } this.swap(arr, i, minIndex); } } } 快速排序 // ../../../../../src/main/java/com/dll/sort/QuickSort.java package com.dll.sort; public class QuickSort { private void swap(int[] arr, int first, int second) { int temp = arr[first]; arr[first] = arr[second]; arr[second] = temp; } private void sort_recursion(int[] arr, int start, int end) { if (start \u0026gt;= end) { return; } int pivot = arr[start]; int l = start, r = end; while (l \u0026lt; r) { while (arr[r] \u0026gt;= pivot \u0026amp;\u0026amp; l \u0026lt; r) { r--; } while (arr[l] \u0026lt;= pivot \u0026amp;\u0026amp; l \u0026lt; r) { l++; } this.swap(arr, l, r); } this.swap(arr, start, l); this.sort_recursion(arr, start, l - 1); this.sort_recursion(arr, l + 1, end); } public void sort(int[] arr) { this.sort_recursion(arr, 0, arr.length - 1); } } 归并排序 // ../../../../../src/main/java/com/dll/sort/MergeSort.java package com.dll.sort; import java.util.Arrays; public class MergeSort { /** * 用于合并两个升序的数组 */ public int[] mergeSortedArray(int[] arr1, int[] arr2) { int[] merged = new int[arr1.length + arr2.length]; int i = 0; int j = 0; int k = 0; while (i \u0026lt; arr1.length \u0026amp;\u0026amp; j \u0026lt; arr2.length) { merged[k++] = arr1[i] \u0026gt; arr2[j] ? arr2[j++] : arr1[i++]; } while (i \u0026lt; arr1.length) { merged[k++] = arr1[i++]; } while (j \u0026lt; arr2.length) { merged[k++] = arr2[j++]; } return merged; } // [start, mid) // [mid, end) public int[] merge(int[] arr, int start, int mid, int end) { int[] t1 = Arrays.copyOfRange(arr, start, mid); int[] t2 = Arrays.copyOfRange(arr, mid, end); int[] result = this.mergeSortedArray(t1, t2); for (int i = 0; i \u0026lt; result.length; i++) { arr[start + i] = result[i]; } return result; } public void splitAndMerge(int[] arr, int start, int end) { if (end - start \u0026lt;= 1) { return; } int mid = start + (end - start) / 2; this.splitAndMerge(arr, start, mid); this.splitAndMerge(arr, mid, end); this.merge(arr, start, mid, end); } public void sort(int[] arr) { this.splitAndMerge(arr, 0, arr.length); } } 插入排序 // ../../../../../src/main/java/com/dll/sort/InsertSort.java package com.dll.sort; /** * 插入排序将数组分为两个部分:有序部分和待排序部分 * 待排序部分中的每个元素和有序部分的每个元素做比较，并插入到合适的位置 * 第一个元素本身就是有序的，不需要排序 * 从第二个元素开始，每次都比较 */ public class InsertSort { public void sort(int[] arr) { for (int i = 1; i \u0026lt; arr.length; i++) { for (int j = 0; j \u0026lt; i; j++) { if (arr[i] \u0026lt; arr[j]) { int temp = arr[i]; for (int z = i - 1; z \u0026gt;= j; z--) { arr[z + 1] = arr[z]; } arr[j] = temp; } } } } } 215. Kth Largest Element in an Array 两数的交换 排序过程中经常会使用到两个数值的交换，常用的，我们会使用 temp variable 作为媒介，如：\nt = a; a = b; b = t; 有没有不耗费空间，或者更快的方式呢？\n数值运算交换两个元素\na = a + b // a1 = a + b b = a - b // b = a1 - b -\u0026gt; b = a a = a - b // a = a1 - b -\u0026gt; a = a1 - a -\u0026gt; a = b 异或运算交换两个元素\na = a ^ b // a1 = a ^ b b = a ^ b // b = a1 ^ b -\u0026gt; a ^ b ^ b = a a = a ^ b // a = a1 ^ b -\u0026gt; a ^ b ^ a = b "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E8%B4%AA%E5%BF%83/","title":"贪心","tags":[],"description":"","content":"贪心 455. 分发饼干 leetcode\n对每块饼干都去匹配一下胃口，满足饼干 \u0026gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列 // ../../../../../src/main/java/com/dll/greedy/AssignCookies.java package com.dll.greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename int[] appetites = g; int[] cookies = s; // ascending Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter \u0026lt; appetites.length \u0026amp;\u0026amp; cookie \u0026gt;= appetites[counter]) { counter++; } } return counter; } } } 135. 分发糖果 leetcode\n我的思路 把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1 如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -\u0026gt; [1,1,1,1,1,1,1] 1 -\u0026gt; [1,2,1,1,1,1,1] 2 -\u0026gt; [1,2,3,1,1,1,1] 3 -\u0026gt; [1,2,3,1,3,1,1] 5 -\u0026gt; [1,2,3,4,3,1,1] 7 -\u0026gt; [1,2,3,4,2,1,2] 书上思路 把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1 // ../../../../../src/main/java/com/dll/greedy/Candy.java package com.dll.greedy; import java.util.Arrays; import java.util.Optional; import java.util.stream.IntStream; public class Candy { class Solution { public int candy(int[] ratings) { // use candy array to store result int[] candy = new int[ratings.length]; // uniq and ascending int[] uniqAndSortedRats = IntStream.of(ratings).distinct().sorted().toArray(); // set default value Arrays.fill(candy, 1); for (int uasr : uniqAndSortedRats) { for (int i = 0; i \u0026lt; ratings.length; i++) { if (uasr == ratings[i]) { this.updateCandy(ratings, candy, i); } } System.out.println(Arrays.toString(candy)); } return IntStream.of(candy).sum(); } Optional\u0026lt;Integer\u0026gt; getLeftValue(int[] arr, int index) { if (index == 0) { return Optional.empty(); } return Optional.of(arr[index - 1]); } Optional\u0026lt;Integer\u0026gt; getRightValue(int[] arr, int index) { if (index == arr.length - 1) { return Optional.empty(); } return Optional.of(arr[index + 1]); } int max(int a, int b) { return a \u0026gt; b ? a : b; } void updateCandy(int[] ratings, int[] candy, int index) { // 判断 ratings[index] 是否存在比 ratings[index - 1] or ratings[index + 1] 大 // true 则按照如下更新： // 1. 左右均比其大，则取 max(candy[index-1], candy(index+1)) + 1 // 2. 一侧大则取一侧的值 + 1 // false 则不更新 int current = ratings[index]; Optional\u0026lt;Integer\u0026gt; leftRatingsValue = getLeftValue(ratings, index); Optional\u0026lt;Integer\u0026gt; rightRatingsValue = getRightValue(ratings, index); Optional\u0026lt;Integer\u0026gt; leftCandyValue = getLeftValue(candy, index); Optional\u0026lt;Integer\u0026gt; rightCandyValue = getRightValue(candy, index); if ((leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) \u0026amp;\u0026amp; (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current)) { candy[index] = max(leftCandyValue.get(), rightCandyValue.get()) + 1; } else if (leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) { candy[index] = leftCandyValue.get() + 1; } else if (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current) { candy[index] = rightCandyValue.get() + 1; } } } } 435. 无重叠区间 leetcode\n我的思路 错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：\n[5,7] [3,6] [6,20] 正确应该是去除 [5,7] 区间 但是按照我的思路会选 [5,7] 去除 [3,6] [6,20] 区间 书上思路 按照区间右端点升序排列，且一直维护当前右端点为不重复区间的最大右端点\n// ../../../../../src/main/java/com/dll/greedy/NonOverlappingIntervals.java package com.dll.greedy; import java.util.Arrays; import java.util.Comparator; public class NonOverlappingIntervals { class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length \u0026lt; 1) { return 0; } Arrays.sort(intervals, Comparator.comparingInt(o -\u0026gt; o[1])); int end = intervals[0][1]; int counter = 0; for (int i = 1; i \u0026lt; intervals.length; i++) { if (intervals[i][0] \u0026lt; end) { counter++; } else { end = intervals[i][1]; } } return counter; } } } 605. 种花问题 leetcode\n我的思路 在 1 的左右侧设置\u0026rsquo;障碍物\u0026rsquo;, 用 2 代表, 根据连续多少个 0, 能发现如下规律:\n连续 1 个 0 -\u0026gt; 可种 1 朵花 连续 2 个 0 -\u0026gt; 可种 1 朵花 连续 3 个 0 -\u0026gt; 可种 2 朵花 连续 n 个 0 -\u0026gt; 可种 (n+1)/2 朵花 // ../../../../../src/main/java/com/dll/greedy/CanPlaceFlowers.java package com.dll.greedy; public class CanPlaceFlowers { class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int zeroCountContinuous = 0; int counter = 0; for (int i = 0; i \u0026lt; flowerbed.length; i++) { if (flowerbed[i] == 1) { if (i - 1 \u0026gt;= 0) { flowerbed[i - 1] = 2; if (zeroCountContinuous \u0026gt; 0) { zeroCountContinuous--; } } if (i + 1 \u0026lt; flowerbed.length) { flowerbed[i + 1] = 2; } counter += (zeroCountContinuous + 1) / 2; zeroCountContinuous = 0; } else if (flowerbed[i] == 0) { zeroCountContinuous++; } } if (zeroCountContinuous \u0026gt; 0) { counter += (zeroCountContinuous + 1) / 2; } return counter \u0026gt;= n; } } } 贪心策略 (TODO) 遍历，能种就种（在可种的时候不种都不会得到更优解）\n452. 用最少数量的箭引爆气球 leetcode\n|----| A |---| B |----| C |------------| D |--| E 通过观察不难发现可以取任一线段(气球), 尝试找与其有交集的任一线段, 若不存在, 则此线段是独立线段, 花费一支箭, 若存在, 则继续找下一条与该交集相交的线段（尽可能多的）, 直至不存在, 花费一支箭\n然而写完代码发现这个思路竟然是错误的！\n例: [3,8],[7,12],[9,10],[0,6]\n|---| [3,8] A |------------| [7,12] B |---| [9,10] C |----| [0,6] D 按照代码逻辑: AB 一箭, C 一箭, D 一箭 事实存在更优: AD 一箭, BC 一箭 进一步, 如果按照其左或右端点排序, 就能 AC 该问题(虽然效率很低)\n|----| [0,6] D |---| [3,8] A |---| [9,10] C |------------| [7,12] B // ../../../../../src/main/java/com/dll/greedy/MinimumNumberOfArrowsToBurstBalloons.java package com.dll.greedy; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List; public class MinimumNumberOfArrowsToBurstBalloons { class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, Comparator.comparingInt(o -\u0026gt; o[1])); List\u0026lt;int[]\u0026gt; balloons = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(points)); int arrows = 0; while (!balloons.isEmpty()) { int[] p1 = balloons.get(0); balloons.remove(0); for (int i = 0; i \u0026lt; balloons.size(); i++) { if ((balloons.get(i)[0] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[0] \u0026lt;= p1[1]) || (balloons.get(i)[1] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026lt;= p1[1]) || (balloons.get(i)[0] \u0026lt; p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026gt; p1[1])) { int start = balloons.get(i)[0] \u0026gt; p1[0] ? balloons.get(i)[0] : p1[0]; int end = balloons.get(i)[1] \u0026lt; p1[1] ? balloons.get(i)[1] : p1[1]; p1 = new int[]{start, end}; balloons.remove(i--); } } arrows++; } return arrows; } } } 为啥排序能解决问题？\n排序解除了\u0026rsquo;剩两端\u0026rsquo;的问题, 如上例中, 当 AB 组合的时候, 可能会同时存在类似 C.start \u0026gt; A.end , D.end \u0026lt; B.start 的情形, 而排序后刚好破坏了这种情形\n|---| [3,8] A |------------| [7,12] B |\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; C \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;| D "},{"uri":"https://nosugarcoffee.github.io/leetcode/","title":"Introduction","tags":[],"description":"","content":"LeetCode solutions writing in java. Rendered by hugo \u0026amp; github pages. You can visit here for a happy reading.\nLocal Development And Preview Add comment of relative file path in .md which you want to include, like following:\n// ../../../../src/lrucache_146/LRUCache.java Run npx embedme README.md\nRun hugo server under web directory\nGithub Actions Use super-linter for code lint\nUse setup-java for maven test\nUse actions-hugo for pages deploy\nCopywriting Following chinese-copywriting-guidelines Q\u0026amp;A How to embed source code by link rather than COPY\u0026amp;PASTE in README ? You can use this tool written by js. "}]