[{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%95%B0%E7%BB%84/","title":"数组","tags":[],"description":"","content":"N 数之和相关问题 两数之和 1\n// ../../../../src/main/java/com/dll/array/TwoSum.java  package com.dll.array; import java.util.HashMap; import java.util.Map; public class TwoSum { // 1. 暴力法  class Solution { public int[] twoSum(int[] nums, int target) { for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return new int[]{-1, -1}; } } // 2. hash  class Solution2 { public int[] twoSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (map.containsKey(target - nums[i])) { return new int[]{map.get(target - nums[i]), i}; } map.put(nums[i], i); } return new int[]{-1, -1}; } } } 两数之和 II - 输入有序数组 167\n 使用指针 ps 指向数组开头, 指针 pe 指向数组末尾 当 numbers[ps] + numbers[pe] \u0026gt; target, 则 pe 向前移动, 否则 ps 向后移动, 直到 = target  // ../../../../src/main/java/com/dll/array/TwoSumIIInputArrayIsSorted.java  package com.dll.array; public class TwoSumIIInputArrayIsSorted { class Solution { // 1. 双指针  public int[] twoSum(int[] numbers, int target) { int ps = 0; int pe = numbers.length - 1; while (ps \u0026lt; pe) { if (numbers[ps] + numbers[pe] == target) { return new int[]{ps + 1, pe + 1}; } else if (numbers[ps] + numbers[pe] \u0026gt; target) { pe--; } else { ps++; } } return new int[]{-1, -1}; } } } 三数之和 15\n// ../../../../src/main/java/com/dll/array/ThreeSum.java  package com.dll.array; import java.util.*; public class ThreeSum { // 1. 双重循环 + hash 法  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { map.put(nums[i], i); } Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { int z = -nums[i] - nums[j]; if (map.containsKey(z) \u0026amp;\u0026amp; map.get(z) != i \u0026amp;\u0026amp; map.get(z) != j) { Integer[] array = new Integer[]{nums[i], nums[j], z}; Arrays.sort(array); set.add(Arrays.asList(array)); } } } return new ArrayList\u0026lt;\u0026gt;(set); } } // 2. } 四数之和 18\n// ../../../../src/main/java/com/dll/array/FourSum.java  package com.dll.array; import java.util.*; public class FourSum { // 三重循坏 + hash  class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; fourSum(int[] nums, int target) { Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { map.put(nums[i], i); } Set\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { for (int j = i + 1; j \u0026lt; nums.length; j++) { for (int k = j + 1; k \u0026lt; nums.length; k++) { int z = target - nums[i] - nums[j] - nums[k]; if (map.containsKey(z) \u0026amp;\u0026amp; map.get(z) != i \u0026amp;\u0026amp; map.get(z) != j \u0026amp;\u0026amp; map.get(z) != k) { Integer[] array = new Integer[]{nums[i], nums[j], nums[k], z}; Arrays.sort(array); set.add(Arrays.asList(array)); } } } } return new ArrayList\u0026lt;\u0026gt;(set); } } } 组合 77\n经过上面的 2/3/4 数之和问题的探索，发现如果要求 \u0026ldquo;N 个数之和为 target 的全部组合\u0026rdquo; 还是有点力不从心，本质上是需要求出给定数组的全部组合，所以先解此题\n// ../../../../src/main/java/com/dll/array/Combinations.java  package com.dll.array; import java.util.*; import java.util.stream.IntStream; public class Combinations { // 1. 递归  class Solution { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private int k; private int[] data; private void init(int[] data, int k) { this.data = data; this.k = k; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[]{}; } return result; } private void recursion(int[] remain, List\u0026lt;Integer\u0026gt; prevPath) { if (prevPath.size() == k) { result.add(prevPath); return; } for (int i = 0; i \u0026lt; remain.length; i++) { List\u0026lt;Integer\u0026gt; curPath = new ArrayList\u0026lt;\u0026gt;(prevPath); curPath.add(remain[i]); this.recursion(this.remain(remain, i), curPath); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { this.init(IntStream.rangeClosed(1, n).toArray(), k); this.recursion(this.data, Collections.emptyList()); return result; } } // 2. 递归（回溯）  class Solution2 { private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); // 遍历过程中的实时路径  private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int k; private int[] data; private void init(int[] data, int k) { this.data = data; this.k = k; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[]{}; } return result; } private void recursion(int[] remain) { if (this.path.size() == k) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } for (int i = 0; i \u0026lt; remain.length; i++) { path.add(remain[i]); this.recursion(this.remain(remain, i)); // 回溯  path.remove(path.size() - 1); } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { this.init(IntStream.rangeClosed(1, n).toArray(), k); this.recursion(this.data); return result; } } } 组合总和 II 40\n该题就是 组合 提到的 \u0026ldquo;N 数之和为 target 的全部组合问题\u0026rdquo;, 思路同上\n// ../../../../src/main/java/com/dll/array/CombinationSumII.java  package com.dll.array; import java.util.ArrayList; import java.util.Arrays; import java.util.List; public class CombinationSumII { class Solution { private List\u0026lt;Integer\u0026gt; path = new ArrayList\u0026lt;\u0026gt;(); private int[] sorted_candidates; private int[] candidates; private int target; private List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); private int sum = 0; private void init(int[] candidates, int target) { this.candidates = candidates; int[] candidatesCopy = Arrays.copyOf(candidates, candidates.length); Arrays.sort(candidatesCopy); this.sorted_candidates = candidatesCopy; this.target = target; } private int[] remain(int[] array, int index) { int[] result; try { result = Arrays.copyOfRange(array, index + 1, array.length); } catch (Exception e) { result = new int[]{}; } return result; } private boolean ifSkipOnContinuesEqual(int[] remain, int index) { return index - 1 \u0026gt;= 0 \u0026amp;\u0026amp; remain[index] == remain[index - 1]; } private void recursion(int[] remain) { if (sum == this.target) { result.add(new ArrayList\u0026lt;\u0026gt;(path)); return; } else if (sum \u0026gt; this.target) { return; } for (int i = 0; i \u0026lt; remain.length; i++) { if (this.ifSkipOnContinuesEqual(remain, i)) { continue; } path.add(remain[i]); sum += remain[i]; this.recursion(this.remain(remain, i)); int val = path.remove(path.size() - 1); sum -= val; } } public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { this.init(candidates, target); this.recursion(this.sorted_candidates); return result; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%AD%97%E7%AC%A6%E4%B8%B2/","title":"字符串","tags":[],"description":"","content":"反转字符串 344 // ../../../../../src/main/java/com/dll/string/ReverseString.java  package com.dll.string; public class ReverseString { class Solution { private void swap(char[] s, int p, int q) { char temp = s[p]; s[p] = s[q]; s[q] = temp; } public void reverseString(char[] s) { if (s.length \u0026lt;= 1) { return; } for (int i = 0; i \u0026lt; s.length / 2; i++) { int p = i; int q = s.length -1 - i; swap(s, p, q); } } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/","title":"算法分类","tags":[],"description":"","content":""},{"uri":"https://nosugarcoffee.github.io/leetcode/%E5%89%91%E6%8C%87-offer/","title":"剑指 offer","tags":[],"description":"","content":"04. 二维数组中的查找 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer04.java  package com.dll.offer; public class Offer04 { class Solution { public boolean findNumberIn2DArray(int[][] matrix, int target) { int rows; if (matrix == null || (rows = matrix.length) \u0026lt; 1) { return false; } int cols = matrix[0].length; int i = 0; int j = cols - 1; while (i \u0026lt; rows \u0026amp;\u0026amp; j \u0026gt; -1) { int upperRightCorner = matrix[i][j]; if (upperRightCorner == target) { return true; } else if (upperRightCorner \u0026gt; target) { j--; } else { i++; } } return false; } } } 05. 替换空格 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer05.java  package com.dll.offer; import java.util.stream.Stream; public class Offer05 { class Solution { public String replaceSpace(String s) { if (s == null) { return \u0026#34;\u0026#34;; } StringBuilder sb = new StringBuilder(); Stream.of(s.split(\u0026#34;\u0026#34;)).forEach(ss -\u0026gt; { if (\u0026#34; \u0026#34;.equals(ss)) { sb.append(\u0026#34;%20\u0026#34;); } else { sb.append(ss); } }); return sb.toString(); } } } 06. 从尾到头打印链表 leetcode\n递归法 // ../../../../src/main/java/com/dll/offer/Offer06.java  package com.dll.offer; import java.util.ArrayList; import java.util.List; public class Offer06 { class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public int[] reversePrint(ListNode head) { return this.recursion(head).stream().mapToInt(i -\u0026gt; i).toArray(); } private List\u0026lt;Integer\u0026gt; recursion(ListNode node) { if (node == null) { return new ArrayList\u0026lt;\u0026gt;(); } List\u0026lt;Integer\u0026gt; list = this.recursion(node.next); list.add(node.val); return list; } } } 07. 重建二叉树 leetcode\n根据前序和中序遍历的规则，前序遍历总是将树分割成 {根 [左子树] [右子树]}，中序遍历则将树分割成 {[左子树] 根 [右子树]}，两者左右子树的成员应该保持一致。\n具体的，当还原前序遍历为 {1,2,4,7,3,5,6,8}，中序遍历为 {4,7,2,1,5,3,8,6} 的树时，需要经历以下步骤:\n  根据前序遍历 {1,2,4,7,3,5,6,8} 可得 1 是树的根结点\n  结合中序遍历可知左子树中序结果为 {4,7,2}, 前序结果为 {2,4,7}, 右子树中序结果为 {5,3,8,6}, 前序结果为 {3,5,6,8}\n  对子树重复上述步骤\n  伪代码表示一个流程如下：\npreorder = [1,2,4,7,3,5,6,8] inorder = [4,7,2,1,5,3,8,6] root = preorder[0] # 拆分成两颗子树 subLeftTreeInorder, subRightTreeInorder = splitInorder(root) subLeftTreeInorderlength = subLeftTreeInorder.length() subRightTreeInorderlength = subRightTreeInorder.length() subLeftTreePreorder = preorder[1:subLeftTreeInorderlength] subRightTreePreorder = preorder[subLeftTreeInorderlength:subRightTreeInorderlength] subLeftTreeRoot = subLeftTreePreorder[0] subRightTreeRoot = subRightTreePreorder[0] root.left = subLeftTreeRoot root.right = subRightTreeRoot 经过上述直叙的方式，可以抽象成如下递归体：\nfunc Node rec(preorder, inorder) { root = preorder[0] subLeftTreeInorder, subRightTreeInorder = splitInorder(preorder[0]) subLeftTreeInorderlength = subLeftTreeInorder.length() subRightTreeInorderlength = subRightTreeInorder.length() subLeftTreePreorder = preorder[1:subLeftTreeInorderlength] subRightTreePreorder = preorder[subLeftTreeInorderlength:subRightTreeInorderlength] left = rec(subLeftTreePreorder, subLeftTreeInorder) right = rec(subRightTreePreorder, subRightTreeInorder) root.left = left root.right = right return root } // ../../../../src/main/java/com/dll/offer/Offer07.java  package com.dll.offer; import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.Deque; import java.util.List; import java.util.Map; import java.util.TreeMap; public class Offer07 { class LevelTreeNode { TreeNode node; int level; public LevelTreeNode(TreeNode node, int level) { this.node = node; this.level = level; } } class TreeNode { int val; TreeNode left; TreeNode right; TreeNode(int val) { this.val = val; } } class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { if (preorder == null || inorder == null || preorder.length == 0 || inorder.length == 0) { return null; } if (preorder.length != inorder.length) { throw new RuntimeException( String.format(\u0026#34;internal error, preorder:%s inorder:%s\u0026#34;, Arrays.toString(preorder), Arrays.toString(inorder))); } int rootValue = preorder[0]; int[][] subTreeInorder = this.splitInorder(inorder, rootValue); int[] leftInorder = subTreeInorder[0]; int[] rightInorder = subTreeInorder[1]; int leftTreeLength = leftInorder.length; int rightTreeLength = rightInorder.length; int[] leftPreorder = new int[]{}; int[] rightPreorder = new int[]{}; if (leftTreeLength \u0026gt; 0) { leftPreorder = Arrays.copyOfRange(preorder, 1, 1 + leftTreeLength); } if (rightTreeLength \u0026gt; 0) { rightPreorder = Arrays.copyOfRange(preorder, 1 + leftTreeLength, preorder.length); } TreeNode left = buildTree(leftPreorder, leftInorder); TreeNode right = buildTree(rightPreorder, rightInorder); TreeNode root = new TreeNode(rootValue); root.left = left; root.right = right; return root; } private int findIndexInArray(int[] array, int root) { int index = 0; for (int value: array) { if (value == root) { return index; } index++; } return -1; } int[][] splitInorder(int[] inorder, int root) { int rootIndex = this.findIndexInArray(inorder, root); if (rootIndex == -1) { return new int[][]{{},{}}; } int[] left = Arrays.copyOfRange(inorder, 0, rootIndex); int[] right = Arrays.copyOfRange(inorder, rootIndex + 1, inorder.length); return new int[][]{left, right}; } // this also can solve problem https://leetcode-cn.com/problems/binary-tree-level-order-traversal/  public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { // map key is level, map value is the list of node value  if (root == null) { return new ArrayList\u0026lt;\u0026gt;(new ArrayList\u0026lt;\u0026gt;()); } Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; map = new TreeMap\u0026lt;\u0026gt;(Comparator.comparingInt(Integer::valueOf)); Deque\u0026lt;LevelTreeNode\u0026gt; queue = new ArrayDeque\u0026lt;\u0026gt;(); queue.offer(new LevelTreeNode(root, 0)); while (!queue.isEmpty()) { LevelTreeNode n = queue.poll(); List\u0026lt;Integer\u0026gt; list = map.getOrDefault(n.level, new ArrayList\u0026lt;\u0026gt;()); map.put(n.level, list); list.add(n.node.val); if (n.node.left != null) { queue.offer(new LevelTreeNode(n.node.left, n.level + 1)); } if (n.node.right != null) { queue.offer(new LevelTreeNode(n.node.right, n.level + 1)); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } } 09. 用两个栈实现队列 leetcode\n利用两个栈, deQueueStack 以及 enQueueStack\n 入队只从 enQueueStack 进 出队只从 deQueueStack 出，deQueueStack 内有元素时直接出队, 无元素时转移全部 enQueueStack 到 deQueueStack  // ../../../../src/main/java/com/dll/offer/Offer09.java  package com.dll.offer; import java.util.Deque; import java.util.LinkedList; import java.util.NoSuchElementException; public class Offer09 { class CQueue { Deque\u0026lt;Integer\u0026gt; inQueueStack = new LinkedList\u0026lt;\u0026gt;(); Deque\u0026lt;Integer\u0026gt; deQueueStack = new LinkedList\u0026lt;\u0026gt;(); public CQueue() { } public void appendTail(int value) { inQueueStack.push(value); } private int popWrapper() { try { return deQueueStack.pop(); } catch (NoSuchElementException e) { return -1; } } public int deleteHead() { if (deQueueStack.isEmpty()) { while (!inQueueStack.isEmpty()) { deQueueStack.push(inQueueStack.pop()); } } return popWrapper(); } } } 10- I. 斐波那契数列 leetcode\n直接递归会超时，所以加了个简易的 cache\n// ../../../../src/main/java/com/dll/offer/Offer10I.java  package com.dll.offer; import java.util.HashMap; import java.util.Map; public class Offer10I { class Solution { Map\u0026lt;Integer, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); public int fib(int n) { if (cache.containsKey(n)) { return cache.get(n); } if (n \u0026lt; 2) { return n; } int val = (fib(n - 1) + fib(n - 2)) % 1000000007; cache.put(n, val); return val; } } } 10- II. 青蛙跳台阶问题 leetcode\n斐波那契数列包了一层背景，原理一样\n// ../../../../src/main/java/com/dll/offer/Offer10II.java  package com.dll.offer; import java.util.HashMap; import java.util.Map; public class Offer10II { class Solution { Map\u0026lt;Integer, Integer\u0026gt; cache = new HashMap\u0026lt;\u0026gt;(); private int recu(int n) { if (cache.containsKey(n)) { return cache.get(n); } if (n == 0 || n == 1) { return 1; } int val = (recu(n - 1) + recu(n - 2)) % 1000000007; cache.put(n, val); return val; } public int numWays(int n) { return recu(n); } } } 11. 旋转数组的最小数字 这题直接用暴力法解了，因为个人觉得题目没什么太大实际意义 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer11.java  package com.dll.offer; public class Offer11 { class Solution { public int minArray(int[] numbers) { if (numbers == null || numbers.length \u0026lt; 1) { throw new RuntimeException(); } int min = numbers[0]; for (int i = 1; i \u0026lt; numbers.length; i++) { if (numbers[i] \u0026lt; numbers[i - 1]) { min = numbers[i]; break; } } return min; } } } 13. 机器人的运动范围 leetcode\n这题有坑，开始以为按照如下代码可解，提交后一直不能 ac\nclass Solution { int calc(int num) { int sum = 0; while(num != 0) { sum += num % 10; num /= 10; } return sum; } public int movingCount(int m, int n, int k) { int counter = 0; for(int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if ((calc(i) + calc(j)) \u0026lt;= k ) { counter++; } } } return counter; } } 翻看评论才知道，有如下二维数组，当 k = 8 时，机器人无法从第九行或者第九列跨过去\n0 1 2 3 4 5 6 7 8 9 10 0 可 可 可 可 可 可 可 可 可 不 可 1 可 可 可 可 可 可 可 可 不 不 可 2 可 可 可 可 可 可 可 不 不 不 可 3 可 可 可 可 可 可 不 不 不 不 可 4 可 可 可 可 可 不 不 不 不 不 可 5 可 可 可 可 不 不 不 不 不 不 可 6 可 可 可 不 不 不 不 不 不 不 可 7 可 可 不 不 不 不 不 不 不 不 可 8 可 不 不 不 不 不 不 不 不 不 不 9 不 不 不 不 不 不 不 不 不 不 不 10可 可 可 可 可 可 可 可 可 可 不 （可为可到达的，不为不可到达的） 代码：\n// ../../../../src/main/java/com/dll/offer/Offer13.java  package com.dll.offer; public class Offer13 { class Solution { int mLen; int nLen; int k; int[][] visited; private int calc(int num) { int sum = 0; while(num != 0) { sum += num % 10; num /= 10; } return sum; } public int dfs(int i, int j) { if ( i \u0026gt;= mLen || j \u0026gt;= nLen) { return 0; } if (visited[i][j] == 1) { return 0; } visited[i][j] = 1; if (calc(i) + calc(j) \u0026gt; this.k) { return 0; } return 1 + this.dfs(i + 1, j) + this.dfs(i, j + 1); } private void init(int m, int n, int k) { this.mLen = m; this.nLen = n; this.k = k; this.visited = new int[m][n]; } public int movingCount(int m, int n, int k) { this.init(m, n, k); return this.dfs(0, 0); } } } 18. 删除链表的节点 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer18.java  package com.dll.offer; public class Offer18 { class ListNode { int val; ListNode next; ListNode(int x) { val = x; } } class Solution { public ListNode deleteNode(ListNode head, int val) { ListNode pre = null; ListNode cur = head; while (cur != null) { if (cur.val == val) { if (pre == null) { cur = cur.next; head = cur; } else { pre.next = cur.next; cur = cur.next; } } else { pre = cur; cur = cur.next; } } return head; } } } 24. 反转链表 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer24.java  package com.dll.offer; public class Offer24 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode current = head; ListNode next = null; while(current != null) { next = current.next; current.next = prev; prev = current; current = next; } return prev; } } } 25. 合并两个排序的链表 leetcode\n// ../../../../src/main/java/com/dll/offer/Offer25.java  package com.dll.offer; public class Offer25 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode p1 = l1; ListNode p2 = l2; ListNode dummy = new ListNode(-1); ListNode last = dummy; while(p1 != null \u0026amp;\u0026amp; p2 != null) { if ( p1.val \u0026gt; p2.val) { last.next = p2; p2 = p2.next; } else { last.next = p1; p1 = p1.next; } last = last.next; } if (p1 != null) { last.next = p1; } if (p2 != null) { last.next = p2; } return dummy.next; } } } 52. 两个链表的第一个公共节点 leetcode\n 要比较的是 node 是否相等，而不是 value 是否相等。 由于是单向链表，即重合后一定是 “Y” 型，而不是 “X” 型，尾部长度一致。 使链表 A 和链表 B 末尾对齐，同时遍历，出现相同结点则直接返回，直到遍历至末尾都没有相同结点则返回 null。  时空复杂度\n 时间复杂度: O(len(A) + len(B))) 空间复杂度：O(1)  // ../../../../src/main/java/com/dll/offer/Offer52.java  package com.dll.offer; public class Offer52 { class ListNode { int val; ListNode next; ListNode(int x) { this.val = x; } } class Solution { public ListNode getIntersectionNOde(ListNode headA, ListNode headB) { ListNode pa = headA; ListNode pb = headB; int lenA = 0; int lenB = 0; while(pa != null) { lenA++; pa = pa.next; } while(pb != null) { lenB++; pb = pb.next; } int distance = Math.abs(lenA - lenB); ListNode pLong = headA; ListNode pShort = headB; if (lenB \u0026gt; lenA) { pLong = headB; pShort = headA; } while(distance-- \u0026gt; 0) { pLong = pLong.next; } while(pLong != null) { if (pLong == pShort) { return pLong; } pLong = pLong.next; pShort = pShort.next; } return null; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E9%93%BE%E8%A1%A8/","title":"链表","tags":[],"description":"","content":"两数相加 2  各个位置上的结点相加并需要考虑进位  // ../../../../../src/main/java/com/dll/linkedList/AddTwoNumbers2.java  package com.dll.linkedList; public class AddTwoNumbers2 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode head = new ListNode(-1); ListNode last = head; int pre = 0; while(l1 != null || l2 != null) { int l1Val = l1 == null? 0: l1.val; int l2Val = l2 == null? 0: l2.val; last.next = new ListNode((l1Val + l2Val + pre) % 10); pre = (l1Val + l2Val + pre) / 10; last = last.next; if (l1 != null) { l1 = l1.next; } if (l2 != null) { l2 = l2.next; } } // 注意此处的进位  if (pre != 0) { last.next = new ListNode(pre); last = last.next; } last.next = null; return head.next; } } } 删除链表的倒数第 N 个结点 19  使用双指针，cur 指向当前结点，pren 指向 cur 的第前 n 个结点，当 cur 走到 null 时，pren 即为需要删除的结点  // ../../../../../src/main/java/com/dll/linkedList/RemoveNthNodeFromEndOfList19.java  package com.dll.linkedList; public class RemoveNthNodeFromEndOfList19 { public class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(-1, head); ListNode p = head; ListNode preOfPren = null; ListNode pren = null; while(p != null \u0026amp;\u0026amp; n \u0026gt; 0) { n--; p = p.next; } if (n \u0026gt; 0) { return null; } preOfPren = dummy; pren = head; while(p != null) { preOfPren = pren; pren = pren.next; p = p.next; } preOfPren.next = pren.next; return dummy.next; } } } 删除排序链表中的重复元素 II 82 // ../../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedListII82.java  package com.dll.linkedList; public class RemoveDuplicatesFromSortedListII82 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode dummy = new ListNode(); ListNode tail = dummy; ListNode cur = head; while(cur != null) { ListNode next = cur.next; if (next == null) { tail.next = cur; tail = tail.next; cur = cur.next; } else if(cur.val != next.val) { tail.next = cur; tail = tail.next; cur = cur.next; } else { cur = findNextUnDuplicatedNodeWithHead(cur); } } tail.next = null; return dummy.next; } /** * find the node closest to the head with different value * example: 1-\u0026gt;2-\u0026gt;2 return 2 * example: 2-\u0026gt;2-\u0026gt;3 return 3 * example: 1-\u0026gt;1-\u0026gt;1 return null * example: null return null * @param head of the list * @return the node closest to the head with different value or null */ ListNode findNextUnDuplicatedNodeWithHead(ListNode head) { if (head == null || head.next == null) { return null; } if (head.val != head.next.val) { return head.next; } return findNextUnDuplicatedNodeWithHead(head.next); } } } 删除排序链表中的重复元素 83 // ../../../../../src/main/java/com/dll/linkedList/RemoveDuplicatesFromSortedList83.java  package com.dll.linkedList; public class RemoveDuplicatesFromSortedList83 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null) { return head; } ListNode pre = head; ListNode cur = head.next; while (cur != null) { if(cur.val == pre.val) { cur = cur.next; pre.next = cur; } else { pre = cur; cur = cur.next; } } return head; } } } 移除链表元素 203  增加一个 dummy 结点使删除头结点和中间结点的逻辑一致 p 总是指向当前需要做逻辑判断的结点， pre 则为 p 的前一个结点 p 指向的结点 val 与给定一致时，删除 p 结点，即 pre.next = p.next pre 与 p 的维护：当结点删除，下一轮的 pre 不需要变动，p = p.next，否则一直保持 pre 和 p 的前进  // ../../../../../src/main/java/com/dll/linkedList/RemoveLinkedListElements203.java  package com.dll.linkedList; public class RemoveLinkedListElements203 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { public ListNode removeElements(ListNode head, int val) { ListNode dummy = new ListNode(-1, head); ListNode pre = dummy; ListNode p = head; while(p != null) { if(p.val == val) { pre.next = p.next; } else { pre = p; } p = p.next; } return dummy.next; } } } 反转链表 206 环形链表 II 142 哈希法 // ../../../../../src/main/java/com/dll/linkedList/LinkedListCycleIIHash.java  package com.dll.linkedList; import java.util.HashSet; import java.util.Set; public class LinkedListCycleIIHash { class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { private Set\u0026lt;ListNode\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); public ListNode detectCycle(ListNode head) { ListNode p = head; while (p != null) { if (set.contains(p)) { return p; } set.add(p); p = p.next; } return null; } } } 快慢指针 该思路比较有趣, 具体如下: 若存在环时, 遍历永不结束。慢指针每次走 1 步, 快指针每次走 2 步, 成环时快指针总是能追上慢指针。那么如何知道入口点, 由已知关系得:\n快指针路径长 = 2 倍慢指针的路径 = n 圈路径长 + a + b 2(a+b) = a+b+(b+c)*n a+b = (b+c)n a = (b+c)n-b a = (b+c)(n-1)+c 从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离 在表头新建指针与 slow 同步移动, 相交处即为入口点\n// ../../../../../src/main/java/com/dll/linkedList/LinkedListCycleIIDoublePoint.java  package com.dll.linkedList; public class LinkedListCycleIIDoublePoint { class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; } } public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow, fast, find; try { find = head; slow = head.next; fast = slow.next; } catch (NullPointerException e) { return null; } while (fast != null) { if (fast == slow) { while (find != slow) { find = find.next; slow = slow.next; } return find; } fast = fast.next; slow = slow.next; if (fast != null) { fast = fast.next; } else { return null; } } return null; } } } 两数相加 II 445 // ../../../../../src/main/java/com/dll/linkedList/AddTwoNumbersII445.java  package com.dll.linkedList; import java.util.ArrayDeque; public class AddTwoNumbersII445 { class ListNode { int val; ListNode next; ListNode() {} ListNode(int val) { this.val = val; } ListNode(int val, ListNode next) { this.val = val; this.next = next; } } class Solution { private ArrayDeque\u0026lt;ListNode\u0026gt; pushToStack(ListNode l) { ArrayDeque\u0026lt;ListNode\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); while(l != null) { stack.push(l); l = l.next; } return stack; } public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ArrayDeque\u0026lt;ListNode\u0026gt; stack1 = pushToStack(l1); ArrayDeque\u0026lt;ListNode\u0026gt; stack2 = pushToStack(l2); ListNode head = new ListNode(-1); head.next = null; int carry = 0; while(!stack1.isEmpty() \u0026amp;\u0026amp; !stack2.isEmpty()) { int s1 = stack1.pop().val; int s2 = stack2.pop().val; head.next = new ListNode((s1 + s2 + carry) % 10, head.next); carry = (s1 + s2 + carry) / 10; } ArrayDeque\u0026lt;ListNode\u0026gt; stack = stack1.isEmpty()? stack2: stack1; while (!stack.isEmpty()) { int val = stack.pop().val; head.next = new ListNode((val + carry) % 10, head.next); carry = (val + carry) / 10; } if (carry \u0026gt; 0) { head.next = new ListNode(carry, head.next); } return head.next; } } } 设计链表 707  维护 dummy 为链表的初始结点，维护 tail 指针指向链表末尾非 null 结点（初始化时 tail = dummy），维护 len 代表当前链表的长度（不计 dummy） 何时更新 tail 指针？  addAtHead(val) 或 addAtIndex(-1, val) 且插入的结点为头结点，更新 tail 为当前插入的结点 deleteAtIndex(index) index 为链表的尾结点，更新 tail 为删除结点的 previous 结点    // ../../../../../src/main/java/com/dll/linkedList/DesignLinkedList707.java  package com.dll.linkedList; public class DesignLinkedList707 { class MyLinkedList { private Node dummy; // tail refs to last one of the list  private Node tail; private int len; class Node { private int val; private Node next; public Node(int val) { this(val, null); } public Node(int val, Node next) { this.val = val; this.next = next; } } /** Initialize your data structure here. */ public MyLinkedList() { dummy = new Node(-1); tail = dummy; } /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */ public int get(int index) { Node p = dummy.next; if (index \u0026lt; 0 || index \u0026gt;= len) { return -1; } while(index \u0026gt; 0) { p = p.next; index--; } return p.val; } /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */ public void addAtHead(int val) { Node pre = dummy; Node p = dummy.next; pre.next = new Node(val, p); len++; if(p == null) { tail = pre.next; } } /** Append a node of value val to the last element of the linked list. */ public void addAtTail(int val) { Node node = new Node(val); tail.next = node; tail = node; len++; } /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */ public void addAtIndex(int index, int val) { Node pre = dummy; Node p = dummy.next; if(index \u0026lt; 0) { this.addAtHead(val); return; } if (index \u0026gt; len) { return; } if (index == len) { this.addAtTail(val); return; } while(index \u0026gt; 0) { index --; pre = p; p = p.next; } pre.next = new Node(val, p); len++; } /** Delete the index-th node in the linked list, if the index is valid. */ public void deleteAtIndex(int index) { Node p = dummy.next; Node pre = dummy; if (index \u0026lt; 0 || index \u0026gt;= len) { return; } while(index \u0026gt; 0) { index--; pre = p; p = p.next; } pre.next = p.next; len--; if (p.next == null) { tail = pre; } } @Override public String toString() { Node p = this.dummy.next; StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;[\u0026#34;); while( p != null) { sb.append(p.val + \u0026#34;-\u0026gt;\u0026#34;); p = p.next; } if (tail == null) { sb.append(\u0026#34;null] tail: null\u0026#34;); } else { sb.append(\u0026#34;null] tail:\u0026#34; + tail.val); } return sb.toString(); } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/lru%E7%BC%93%E5%AD%98/","title":"LRU 缓存","tags":[],"description":"","content":"LRU 缓存机制 146 // ../../../../../src/main/java/com/dll/leetcode/LRUCache146.java  package com.dll.leetcode; import java.util.HashMap; import java.util.Map; public class LRUCache146 { class DoubleLinkedList { private Map\u0026lt;Integer, Node\u0026gt; map; private Node head; private Node tail; private int size; public int getSize() { return this.size; } private DoubleLinkedList() { head = new Node(null, -1, -1, null); tail = new Node(null, -1, -1, null); head.next = tail; tail.prev = head; this.map = new HashMap\u0026lt;\u0026gt;(); } class Node { int key; int value; Node prev; Node next; Node(Node prev, int key, int value, Node next) { this.key = key; this.prev = prev; this.value = value; this.next = next; } } private boolean containsKey(int key) { return this.map.containsKey(key); } public Node get(int key) { return this.map.getOrDefault(key, null); } public void delete(Node node) { Node prev = node.prev; Node next = node.next; prev.next = next; next.prev = prev; this.map.remove(node.key); this.size--; } private Node addFirst(int key, int value) { Node node = new Node(head, key, value, head.next); head.next.prev = node; head.next = node; this.size++; this.map.put(key, node); return node; } private Node deleteLast() { Node deletedPrev = tail.prev.prev; Node deleted = deletedPrev.next; deletedPrev.next = tail; tail.prev = deletedPrev; this.map.remove(deleted.key); return deleted; } } private DoubleLinkedList list = new DoubleLinkedList(); private int capacity; public LRUCache146(int capacity) { if (capacity \u0026lt;= 0) { throw new RuntimeException(); } this.capacity = capacity; } /** * get value by key from cache * @param key key of cache * @return value of key */ public int get(int key) { DoubleLinkedList.Node node = list.get(key); if (node == null) { return -1; } list.delete(node); list.addFirst(node.key, node.value); return node.value; } /** * put key and value to cache * @param key key of cache * @param value value of key */ public void put(int key, int value) { // 1. exist in map -\u0026gt; remove(value) \u0026amp; push(value)  // 2. don\u0026#39;t exist in map -\u0026gt; deque is full -\u0026gt; removeLast \u0026amp; push(value)  // 3. don\u0026#39;t exist in map -\u0026gt; deque is empty -\u0026gt; push(value)  if (list.containsKey(key)) { list.delete(list.get(key)); } else { if (list.getSize() \u0026gt;= this.capacity) { list.deleteLast(); } } list.addFirst(key, value); } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找","tags":[],"description":"","content":"x 的平方根 69 查找满足 a*a \u0026lt;= x 的最大 a 值，对 [1,x] 区间二分法取满足的即可\n// ../../../../../src/main/java/com/dll/binarySearch/MySqrt.java  package com.dll.binarySearch; public class MySqrt { class Solution { public int mySqrt(int x) { int l = 1; int r = x; int result = 0; while (l \u0026lt;= r) { //NOTE: 不考虑 long 一直超出事件限制  int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { result = mid; l = mid + 1; } else { r = mid - 1; } } return result; } } } 在排序数组中查找元素的第一个和最后一个位置 34 使用二分法找出左右边界\n// ../../../../../src/main/java/com/dll/binarySearch/FindFirstAndLastPositionOfElementInSortedArray.java  package com.dll.binarySearch; public class FindFirstAndLastPositionOfElementInSortedArray { class Solution { public int[] searchRange(int[] nums, int target) { int l = 0; int r = nums.length - 1; int res1 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026lt; target) { l = mid + 1; } else { r = mid - 1; if (nums[mid] == target) { res1 = mid; } } } l = 0; r = nums.length - 1; int res2 = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if (nums[mid] \u0026gt; target) { r = mid - 1; } else { l = mid + 1; if (nums[mid] == target) { res2 = mid; } } } return new int[]{res1, res2}; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%8F%8C%E6%8C%87%E9%92%88/","title":"双指针","tags":[],"description":"","content":"合并两个有序数组 88 开辟足够大的 nums3, p1、p2 分别指向两个有序数组初始位置, 存储当前指针指向的较小值至 nums3 且移动指针, 相等则任选\n// ../../../../../src/main/java/com/dll/doublePoint/MergeSortedArray.java  package com.dll.doublePoint; public class MergeSortedArray { class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int[] nums3 = new int[m + n]; int p1 = 0; int p2 = 0; int index = 0; while (p1 \u0026lt; m \u0026amp;\u0026amp; p2 \u0026lt; n) { if (nums1[p1] \u0026lt;= nums2[p2]) { nums3[index] = nums1[p1]; p1++; } else { nums3[index] = nums2[p2]; p2++; } index++; } for (; p1 \u0026lt; m; p1++) { nums3[index++] = nums1[p1]; } for (; p2 \u0026lt; n; p2++) { nums3[index++] = nums2[p2]; } System.arraycopy(nums3, 0, nums1, 0, m + n); } } } 最小覆盖子串 76 滑动窗口 原字符 ori（s），以及需要包含的字符串 need（t），[l,r) 代表当前窗口，r 右滑直至满足条件，此时通过 l 右滑，可能找到最优解，重复直到结束。\n// ../../../../../src/main/java/com/dll/doublePoint/MinimumWindowSubstring.java  package com.dll.doublePoint; import java.util.HashMap; import java.util.Iterator; import java.util.Map; import java.util.Map.Entry; public class MinimumWindowSubstring { class Solution { public Map\u0026lt;Character, Integer\u0026gt; calc_freq(String s) { Map\u0026lt;Character, Integer\u0026gt; freq = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; s.length(); i++) { freq.put(s.charAt(i), freq.getOrDefault(s.charAt(i), 0) + 1); } return freq; } public boolean check(Map\u0026lt;Character, Integer\u0026gt; window_freq, Map\u0026lt;Character, Integer\u0026gt; need_freq) { Iterator\u0026lt;Entry\u0026lt;Character, Integer\u0026gt;\u0026gt; iterator = need_freq.entrySet().iterator(); while (iterator.hasNext()) { Entry\u0026lt;Character, Integer\u0026gt; next = iterator.next(); Character key = next.getKey(); if (!(window_freq.containsKey(key) \u0026amp;\u0026amp; window_freq.get(key) \u0026gt;= next.getValue())) { return false; } } return true; } public String minWindow(String s, String t) { String ori = s; String need = t; int l = 0; int r = 0; String result = \u0026#34;\u0026#34;; Map\u0026lt;Character, Integer\u0026gt; needFreq = calc_freq(need); Map\u0026lt;Character, Integer\u0026gt; window_frep = new HashMap\u0026lt;\u0026gt;(); int endIndex = ori.length() - 1; while (r \u0026lt;= endIndex) { window_frep.put(ori.charAt(r), window_frep.getOrDefault(ori.charAt(r), 0) + 1); while (check(window_frep, needFreq) \u0026amp;\u0026amp; l \u0026lt;= r) { if (\u0026#34;\u0026#34;.equals(result)) { result = ori.substring(l, r + 1); } else { result = ori.substring(l, r + 1).length() \u0026lt; result.length() ? ori.substring(l, r + 1) : result; } window_frep.put(ori.charAt(l), window_frep.getOrDefault(ori.charAt(l), 0) - 1); l++; } r++; } return result; } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%93%88%E5%B8%8C%E8%A1%A8/","title":"哈希表","tags":[],"description":"","content":"有效的字母异位词 242  分别用 map 存储两个字符串的字符词频  // ../../../../../src/main/java/com/dll/hashtable/ValidAnagram.java  package com.dll.hashtable; import java.util.HashMap; import java.util.Map; public class ValidAnagram { class Solution { private Map\u0026lt;Character, Integer\u0026gt; toCharMap(String s) { Map\u0026lt;Character, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); char[] chars = s.toCharArray(); for (char c: chars) { int val = map.getOrDefault(c, 0); map.put(c, val + 1); } return map; } public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } return this.toCharMap(s).equals(this.toCharMap(t)); } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"多线程","tags":[],"description":"","content":"交替打印FooBar 1115 利用 AtomicBoolean 来互斥的访问临界资源\n// ../../../../../src/main/java/com/dll/multithreads/PrintFoobarAlternately.java  package com.dll.multithreads; import java.util.concurrent.atomic.AtomicBoolean; public class PrintFoobarAlternately { class FooBar { private int n; private AtomicBoolean flag = new AtomicBoolean(true); public FooBar(int n) { this.n = n; } public void foo(Runnable printFoo) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { while (!flag.get()) { Thread.yield(); } // printFoo.run() outputs \u0026#34;foo\u0026#34;. Do not change or remove this line.  printFoo.run(); flag.set(false); } } public void bar(Runnable printBar) throws InterruptedException { for (int i = 0; i \u0026lt; n; i++) { while (flag.get()) { Thread.yield(); } // printBar.run() outputs \u0026#34;bar\u0026#34;. Do not change or remove this line.  printBar.run(); flag.set(true); } } } } "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E6%8E%92%E5%BA%8F/","title":"排序","tags":[],"description":"","content":"冒泡排序 // ../../../../../src/main/java/com/dll/sort/BubbleSort.java  package com.dll.sort; public class BubbleSort { private void swap(int[] arr, int i, int j) { int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } public void sort(int[] arr) { boolean swapped = false; for (int i = 0; i \u0026lt; arr.length - 1; i++) { for (int j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { this.swap(arr, j, j + 1); swapped = true; } } if (!swapped) { break; } } } } 选择排序 // ../../../../../src/main/java/com/dll/sort/SelectionSort.java  package com.dll.sort; public class SelectionSort { private void swap(int[] arr, int first, int second) { int temp = arr[first]; arr[first] = arr[second]; arr[second] = temp; } public void sort(int[] arr) { for (int i=0; i \u0026lt; arr.length-1; i++) { int minIndex = i; for (int j=i+1; j \u0026lt; arr.length; j++) { if(arr[j] \u0026lt; arr[minIndex]) { minIndex = j; } } this.swap(arr, i, minIndex); } } } 快速排序 // ../../../../../src/main/java/com/dll/sort/QuickSort.java  package com.dll.sort; public class QuickSort { private void swap(int[] arr, int first, int second) { int temp = arr[first]; arr[first] = arr[second]; arr[second] = temp; } private void sort_recursion(int[] arr, int start, int end) { if (start \u0026gt;= end) { return; } int pivot = arr[start]; int l = start, r = end; while (l \u0026lt; r) { while (arr[r] \u0026gt;= pivot \u0026amp;\u0026amp; l \u0026lt; r) { r--; } while (arr[l] \u0026lt;= pivot \u0026amp;\u0026amp; l \u0026lt; r) { l++; } this.swap(arr, l, r); } this.swap(arr, start, l); this.sort_recursion(arr, start, l - 1); this.sort_recursion(arr, l + 1, end); } public void sort(int[] arr) { this.sort_recursion(arr, 0, arr.length - 1); } } 归并排序 // ../../../../../src/main/java/com/dll/sort/MergeSort.java  package com.dll.sort; import java.util.Arrays; public class MergeSort { /** * 用于合并两个升序的数组 */ public int[] mergeSortedArray(int[] arr1, int[] arr2) { int[] merged = new int[arr1.length + arr2.length]; int i = 0; int j = 0; int k = 0; while (i \u0026lt; arr1.length \u0026amp;\u0026amp; j \u0026lt; arr2.length) { merged[k++] = arr1[i] \u0026gt; arr2[j] ? arr2[j++] : arr1[i++]; } while (i \u0026lt; arr1.length) { merged[k++] = arr1[i++]; } while (j \u0026lt; arr2.length) { merged[k++] = arr2[j++]; } return merged; } // [start, mid)  // [mid, end)  public int[] merge(int[] arr, int start, int mid, int end) { int[] t1 = Arrays.copyOfRange(arr, start, mid); int[] t2 = Arrays.copyOfRange(arr, mid, end); int[] result = this.mergeSortedArray(t1, t2); for (int i = 0; i \u0026lt; result.length; i++) { arr[start + i] = result[i]; } return result; } public void splitAndMerge(int[] arr, int start, int end) { if (end - start \u0026lt;= 1) { return; } int mid = start + (end - start) / 2; this.splitAndMerge(arr, start, mid); this.splitAndMerge(arr, mid, end); this.merge(arr, start, mid, end); } public void sort(int[] arr) { this.splitAndMerge(arr, 0, arr.length); } } 插入排序 // ../../../../../src/main/java/com/dll/sort/InsertSort.java  package com.dll.sort; /** * 插入排序将数组分为两个部分:有序部分和待排序部分 * 待排序部分中的每个元素和有序部分的每个元素做比较，并插入到合适的位置 * 第一个元素本身就是有序的，不需要排序 * 从第二个元素开始，每次都比较 */ public class InsertSort { public void sort(int[] arr) { for (int i = 1; i \u0026lt; arr.length; i++) { for (int j = 0; j \u0026lt; i; j++) { if (arr[i] \u0026lt; arr[j]) { int temp = arr[i]; for (int z = i - 1; z \u0026gt;= j; z--) { arr[z + 1] = arr[z]; } arr[j] = temp; } } } } } 215. Kth Largest Element in an Array 两数的交换 排序过程中经常会使用到两个数值的交换，常用的，我们会使用 temp variable 作为媒介，如：\nt = a; a = b; b = t; 有没有不耗费空间，或者更快的方式呢？\n  数值运算交换两个元素\na = a + b // a1 = a + b b = a - b // b = a1 - b -\u0026gt; b = a a = a - b // a = a1 - b -\u0026gt; a = a1 - a -\u0026gt; a = b   异或运算交换两个元素\na = a ^ b // a1 = a ^ b b = a ^ b // b = a1 ^ b -\u0026gt; a ^ b ^ b = a a = a ^ b // a = a1 ^ b -\u0026gt; a ^ b ^ a = b   "},{"uri":"https://nosugarcoffee.github.io/leetcode/%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB/%E8%B4%AA%E5%BF%83/","title":"贪心","tags":[],"description":"","content":"贪心 455. 分发饼干 leetcode\n 对每块饼干都去匹配一下胃口，满足饼干 \u0026gt;= 胃口，即满足 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列  // ../../../../../src/main/java/com/dll/greedy/AssignCookies.java  package com.dll.greedy; import java.util.Arrays; public class AssignCookies { class Solution { public int findContentChildren(int[] g, int[] s) { // rename  int[] appetites = g; int[] cookies = s; // ascending  Arrays.sort(cookies); Arrays.sort(appetites); int counter = 0; for (int cookie : cookies) { if (counter \u0026lt; appetites.length \u0026amp;\u0026amp; cookie \u0026gt;= appetites[counter]) { counter++; } } return counter; } } } 135. 分发糖果 leetcode\n我的思路  把所有孩子的糖果数初始化为 1 去重且按升序排列评分数组 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1  如 [0,1,2,5,3,2,7]: 得到初始化数组: [1,1,1,1,1,1,1] 得到评分数组: [0,1,2,3,5,7] 更新第一轮: 0 -\u0026gt; [1,1,1,1,1,1,1] 1 -\u0026gt; [1,2,1,1,1,1,1] 2 -\u0026gt; [1,2,3,1,1,1,1] 3 -\u0026gt; [1,2,3,1,3,1,1] 5 -\u0026gt; [1,2,3,4,3,1,1] 7 -\u0026gt; [1,2,3,4,2,1,2] 书上思路  把所有孩子的糖果数初始化为 1 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1  // ../../../../../src/main/java/com/dll/greedy/Candy.java  package com.dll.greedy; import java.util.Arrays; import java.util.Optional; import java.util.stream.IntStream; public class Candy { class Solution { public int candy(int[] ratings) { // use candy array to store result  int[] candy = new int[ratings.length]; // uniq and ascending  int[] uniqAndSortedRats = IntStream.of(ratings).distinct().sorted().toArray(); // set default value  Arrays.fill(candy, 1); for (int uasr : uniqAndSortedRats) { for (int i = 0; i \u0026lt; ratings.length; i++) { if (uasr == ratings[i]) { this.updateCandy(ratings, candy, i); } } System.out.println(Arrays.toString(candy)); } return IntStream.of(candy).sum(); } Optional\u0026lt;Integer\u0026gt; getLeftValue(int[] arr, int index) { if (index == 0) { return Optional.empty(); } return Optional.of(arr[index - 1]); } Optional\u0026lt;Integer\u0026gt; getRightValue(int[] arr, int index) { if (index == arr.length - 1) { return Optional.empty(); } return Optional.of(arr[index + 1]); } int max(int a, int b) { return a \u0026gt; b ? a : b; } void updateCandy(int[] ratings, int[] candy, int index) { // 判断 ratings[index] 是否存在比 ratings[index - 1] or ratings[index + 1] 大  // true 则按照如下更新：  // 1. 左右均比其大，则取 max(candy[index-1], candy(index+1)) + 1  // 2. 一侧大则取一侧的值 + 1  // false 则不更新  int current = ratings[index]; Optional\u0026lt;Integer\u0026gt; leftRatingsValue = getLeftValue(ratings, index); Optional\u0026lt;Integer\u0026gt; rightRatingsValue = getRightValue(ratings, index); Optional\u0026lt;Integer\u0026gt; leftCandyValue = getLeftValue(candy, index); Optional\u0026lt;Integer\u0026gt; rightCandyValue = getRightValue(candy, index); if ((leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) \u0026amp;\u0026amp; (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current)) { candy[index] = max(leftCandyValue.get(), rightCandyValue.get()) + 1; } else if (leftRatingsValue.isPresent() \u0026amp;\u0026amp; leftRatingsValue.get() \u0026lt; current) { candy[index] = leftCandyValue.get() + 1; } else if (rightRatingsValue.isPresent() \u0026amp;\u0026amp; rightRatingsValue.get() \u0026lt; current) { candy[index] = rightCandyValue.get() + 1; } } } } 435. 无重叠区间 leetcode\n我的思路 错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：\n[5,7] [3,6] [6,20] 正确应该是去除 [5,7] 区间 但是按照我的思路会选 [5,7] 去除 [3,6] [6,20] 区间 书上思路 按照区间右端点升序排列，且一直维护当前右端点为不重复区间的最大右端点\n// ../../../../../src/main/java/com/dll/greedy/NonOverlappingIntervals.java  package com.dll.greedy; import java.util.Arrays; import java.util.Comparator; public class NonOverlappingIntervals { class Solution { public int eraseOverlapIntervals(int[][] intervals) { if (intervals.length \u0026lt; 1) { return 0; } Arrays.sort(intervals, Comparator.comparingInt(o -\u0026gt; o[1])); int end = intervals[0][1]; int counter = 0; for (int i = 1; i \u0026lt; intervals.length; i++) { if (intervals[i][0] \u0026lt; end) { counter++; } else { end = intervals[i][1]; } } return counter; } } } 605. 种花问题 leetcode\n我的思路 在 1 的左右侧设置\u0026rsquo;障碍物', 用 2 代表, 根据连续多少个 0, 能发现如下规律:\n连续 1 个 0 -\u0026gt; 可种 1 朵花 连续 2 个 0 -\u0026gt; 可种 1 朵花 连续 3 个 0 -\u0026gt; 可种 2 朵花 连续 n 个 0 -\u0026gt; 可种 (n+1)/2 朵花 // ../../../../../src/main/java/com/dll/greedy/CanPlaceFlowers.java  package com.dll.greedy; public class CanPlaceFlowers { class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { int zeroCountContinuous = 0; int counter = 0; for (int i = 0; i \u0026lt; flowerbed.length; i++) { if (flowerbed[i] == 1) { if (i - 1 \u0026gt;= 0) { flowerbed[i - 1] = 2; if (zeroCountContinuous \u0026gt; 0) { zeroCountContinuous--; } } if (i + 1 \u0026lt; flowerbed.length) { flowerbed[i + 1] = 2; } counter += (zeroCountContinuous + 1) / 2; zeroCountContinuous = 0; } else if (flowerbed[i] == 0) { zeroCountContinuous++; } } if (zeroCountContinuous \u0026gt; 0) { counter += (zeroCountContinuous + 1) / 2; } return counter \u0026gt;= n; } } } 贪心策略 (TODO) 遍历，能种就种（在可种的时候不种都不会得到更优解）\n452. 用最少数量的箭引爆气球 leetcode\n|----| A |---| B |----| C |------------| D |--| E 通过观察不难发现可以取任一线段(气球), 尝试找与其有交集的任一线段, 若不存在, 则此线段是独立线段, 花费一支箭, 若存在, 则继续找下一条与该交集相交的线段（尽可能多的）, 直至不存在, 花费一支箭\n然而写完代码发现这个思路竟然是错误的！\n例: [3,8],[7,12],[9,10],[0,6]\n|---| [3,8] A |------------| [7,12] B |---| [9,10] C |----| [0,6] D 按照代码逻辑: AB 一箭, C 一箭, D 一箭 事实存在更优: AD 一箭, BC 一箭 进一步, 如果按照其左或右端点排序, 就能 AC 该问题(虽然效率很低)\n|----| [0,6] D |---| [3,8] A |---| [9,10] C |------------| [7,12] B // ../../../../../src/main/java/com/dll/greedy/MinimumNumberOfArrowsToBurstBalloons.java  package com.dll.greedy; import java.util.ArrayList; import java.util.Arrays; import java.util.Comparator; import java.util.List; public class MinimumNumberOfArrowsToBurstBalloons { class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, Comparator.comparingInt(o -\u0026gt; o[1])); List\u0026lt;int[]\u0026gt; balloons = new ArrayList\u0026lt;\u0026gt;(Arrays.asList(points)); int arrows = 0; while (!balloons.isEmpty()) { int[] p1 = balloons.get(0); balloons.remove(0); for (int i = 0; i \u0026lt; balloons.size(); i++) { if ((balloons.get(i)[0] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[0] \u0026lt;= p1[1]) || (balloons.get(i)[1] \u0026gt;= p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026lt;= p1[1]) || (balloons.get(i)[0] \u0026lt; p1[0] \u0026amp;\u0026amp; balloons.get(i)[1] \u0026gt; p1[1])) { int start = balloons.get(i)[0] \u0026gt; p1[0] ? balloons.get(i)[0] : p1[0]; int end = balloons.get(i)[1] \u0026lt; p1[1] ? balloons.get(i)[1] : p1[1]; p1 = new int[]{start, end}; balloons.remove(i--); } } arrows++; } return arrows; } } } 为啥排序能解决问题？\n排序解除了\u0026rsquo;剩两端\u0026rsquo;的问题, 如上例中, 当 AB 组合的时候, 可能会同时存在类似 C.start \u0026gt; A.end , D.end \u0026lt; B.start 的情形, 而排序后刚好破坏了这种情形\n|---| [3,8] A |------------| [7,12] B |\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; C \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;| D "},{"uri":"https://nosugarcoffee.github.io/leetcode/","title":"Introduction","tags":[],"description":"","content":"Introduction LeetCode solutions writing in java. Rendered by hugo / github pages.\n"}]