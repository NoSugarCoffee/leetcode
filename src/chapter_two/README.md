# 贪心算法

## [AssignCookies](https://leetcode-cn.com/problems/assign-cookies/submissions/)

### 我的思路
1. 对每块饼干都去匹配一下胃口，满足饼干>= 胃口，即满足
2. 为了不出现如大的饼干被小的胃口占用，即应该使大的饼干分配给大胃口，对饼干和胃口进行升序排列

## [Candy](https://leetcode-cn.com/problems/candy/)

### 我的思路
1. 把所有孩子的糖果数初始化为 1
2. 去重且按升序排列评分数组
3. 依次按照评分数组的顺序去更新糖果数组, 更新当前的位置的糖果数为评分比其高的左或右糖果数(取大值) + 1
```
如 [0,1,2,5,3,2,7]:
得到初始化数组: [1,1,1,1,1,1,1]
得到评分数组: [0,1,2,3,5,7]
更新第一轮:
0 -> [1,1,1,1,1,1,1]
1 -> [1,2,1,1,1,1,1]
2 -> [1,2,3,1,1,1,1]
3 -> [1,2,3,1,3,1,1]
5 -> [1,2,3,4,3,1,1]
7 -> [1,2,3,4,2,1,2]
```

### 书上思路
1. 把所有孩子的糖果数初始化为 1
2. 先从左往右遍历一遍，如果右边孩子的评分比左边的高，则右边孩子的糖果数更新为左边孩子的糖果数加 1
3. 从右往左遍历一遍，如果左边孩子的评分比右边的高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加 1

## [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/) 
### 我的思路
错误思路: 原本想的是优先选择区间小的，但是如下情况就不满足：
```
[5,7] [3,6] [6,20]
正确应该是去除 [5,7] 区间
但是按照我的思路会选 [5,7] 去除 [3,6] [6,20] 区间
```

### 书上思路
按照区间右端点升序排列，且一直维护当前右端点为不重复区间的最大右端点
